-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-parser-typechecker
@version 0.0.0

module Unison.Codebase.Causal
data Causal m h e
One :: RawHash h -> e -> Causal m h e
[currentHash] :: Causal m h e -> RawHash h
[head] :: Causal m h e -> e
Cons :: RawHash h -> e -> (RawHash h, m (Causal m h e)) -> Causal m h e
[currentHash] :: Causal m h e -> RawHash h
[head] :: Causal m h e -> e
[tail] :: Causal m h e -> (RawHash h, m (Causal m h e))
Merge :: RawHash h -> e -> Map (RawHash h) (m (Causal m h e)) -> Causal m h e
[currentHash] :: Causal m h e -> RawHash h
[head] :: Causal m h e -> e
[tails] :: Causal m h e -> Map (RawHash h) (m (Causal m h e))
data Raw h e
RawOne :: e -> Raw h e
RawCons :: e -> RawHash h -> Raw h e
RawMerge :: e -> Set (RawHash h) -> Raw h e
newtype RawHash a
RawHash :: Hash -> RawHash a
[unRawHash] :: RawHash a -> Hash

-- | Focus the current head, keeping the hash up to date.
head_ :: Hashable e => Lens' (Causal m h e) e
one :: Hashable e => e -> Causal m h e
cons :: (Applicative m, Hashable e) => e -> Causal m h e -> Causal m h e
cons' :: Hashable e => e -> RawHash h -> m (Causal m h e) -> Causal m h e
consDistinct :: (Applicative m, Eq e, Hashable e) => e -> Causal m h e -> Causal m h e
uncons :: Applicative m => Causal m h e -> m (Maybe (e, Causal m h e))
hash :: Hashable e => e -> Hash
predecessors :: Causal m h e -> Seq (m (Causal m h e))
type Deserialize m h e = RawHash h -> m (Raw h e)
type Serialize m h e = RawHash h -> Raw h e -> m ()
cachedRead :: MonadIO m => Cache (RawHash h) (Causal m h e) -> Deserialize m h e -> RawHash h -> m (Causal m h e)
threeWayMerge :: forall m h e. (Monad m, Hashable e) => (Maybe e -> e -> e -> m e) -> Causal m h e -> Causal m h e -> m (Causal m h e)
threeWayMerge' :: forall m h e. (Monad m, Hashable e) => (Causal m h e -> Causal m h e -> m (Maybe (Causal m h e))) -> (Maybe e -> e -> e -> m e) -> Causal m h e -> Causal m h e -> m (Causal m h e)
squashMerge' :: forall m h e. (Monad m, Hashable e, Eq e) => (Causal m h e -> Causal m h e -> m (Maybe (Causal m h e))) -> (e -> m e) -> (Maybe e -> e -> e -> m e) -> Causal m h e -> Causal m h e -> m (Causal m h e)
lca :: Monad m => Causal m h e -> Causal m h e -> m (Maybe (Causal m h e))
stepDistinct :: (Applicative m, Eq e, Hashable e) => (e -> e) -> Causal m h e -> Causal m h e
stepDistinctM :: (Applicative m, Functor n, Eq e, Hashable e) => (e -> n e) -> Causal m h e -> n (Causal m h e)
sync :: forall m h e. Monad m => (RawHash h -> m Bool) -> Serialize (StateT (Set (RawHash h)) m) h e -> Causal m h e -> StateT (Set (RawHash h)) m ()
transform :: Functor m => (forall a. m a -> n a) -> Causal m h e -> Causal n h e
unsafeMapHashPreserving :: Functor m => (e -> e2) -> Causal m h e -> Causal m h e2
before :: Monad m => Causal m h e -> Causal m h e -> m Bool
beforeHash :: forall m h e. Monad m => Word -> RawHash h -> Causal m h e -> m Bool
instance GHC.Generics.Generic (Unison.Codebase.Causal.RawHash a)
instance GHC.Classes.Ord (Unison.Codebase.Causal.RawHash a)
instance GHC.Classes.Eq (Unison.Codebase.Causal.RawHash a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Show.Show e => GHC.Show.Show (Unison.Codebase.Causal.Causal m h e)
instance GHC.Classes.Eq (Unison.Codebase.Causal.Causal m h a)
instance GHC.Classes.Ord (Unison.Codebase.Causal.Causal m h a)
instance GHC.Show.Show (Unison.Codebase.Causal.RawHash a)
instance Unison.Hashable.Hashable (Unison.Codebase.Causal.RawHash h)

module Unison.Codebase.Causal.FoldHistory
data FoldHistoryResult a
Satisfied :: a -> FoldHistoryResult a
Unsatisfied :: a -> FoldHistoryResult a
foldHistoryUntil :: forall m h e a. Monad m => (a -> e -> (a, Bool)) -> a -> Causal m h e -> m (FoldHistoryResult a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Causal.FoldHistory.FoldHistoryResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Codebase.Causal.FoldHistory.FoldHistoryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Causal.FoldHistory.FoldHistoryResult a)

module Unison.Codebase.CodeLookup
data CodeLookup v m a
CodeLookup :: (Id -> m (Maybe (Term v a))) -> (Id -> m (Maybe (Decl v a))) -> CodeLookup v m a
[getTerm] :: CodeLookup v m a -> Id -> m (Maybe (Term v a))
[getTypeDeclaration] :: CodeLookup v m a -> Id -> m (Maybe (Decl v a))
transitiveDependencies :: (Monad m, Var v) => CodeLookup v m a -> Set Id -> Id -> m (Set Id)
instance Control.Monad.Morph.MFunctor (Unison.Codebase.CodeLookup.CodeLookup v)
instance (GHC.Classes.Ord v, GHC.Base.Functor m) => GHC.Base.Functor (Unison.Codebase.CodeLookup.CodeLookup v m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Unison.Codebase.CodeLookup.CodeLookup v m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Unison.Codebase.CodeLookup.CodeLookup v m a)

module Unison.Codebase.Editor.DisplayObject
data DisplayObject b a
BuiltinObject :: b -> DisplayObject b a
MissingObject :: ShortHash -> DisplayObject b a
UserObject :: a -> DisplayObject b a
toMaybe :: DisplayObject b a -> Maybe a
instance GHC.Generics.Generic (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance GHC.Base.Functor (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Bifunctor.Bifunctor Unison.Codebase.Editor.DisplayObject.DisplayObject

module Unison.Codebase.Path
newtype Path
Path :: Seq NameSegment -> Path
[toSeq] :: Path -> Seq NameSegment
newtype Path'
Path' :: Either Absolute Relative -> Path'
[unPath'] :: Path' -> Either Absolute Relative
newtype Absolute
Absolute :: Path -> Absolute
[unabsolute] :: Absolute -> Path
newtype Relative
Relative :: Path -> Relative
[unrelative] :: Relative -> Path
class Resolve l r o
resolve :: Resolve l r o => l -> r -> o
pattern Empty :: Path
singleton :: NameSegment -> Path
uncons :: Path -> Maybe (NameSegment, Path)
empty :: Path
absoluteEmpty :: Absolute
relativeEmpty' :: Path'
currentPath :: Path'
prefix :: Absolute -> Path' -> Path

-- | examples: unprefix .foo.bar .blah == .blah (absolute paths left alone)
--   unprefix .foo.bar id == id (relative paths starting w/ nonmatching
--   prefix left alone) unprefix .foo.bar foo.bar.baz == baz (relative
--   paths w/ common prefix get stripped)
unprefix :: Absolute -> Path' -> Path
prefixName :: Absolute -> Name -> Name

-- | what is this? â€”AI
unprefixName :: Absolute -> Name -> Name
type HQSplit = (Path, HQSegment)
type Split = (Path, NameSegment)
type Split' = (Path', NameSegment)
type HQSplit' = (Path', HQSegment)
ancestors :: Absolute -> Seq Absolute
isCurrentPath :: Path' -> Bool
isRoot :: Absolute -> Bool
isRoot' :: Path' -> Bool
absoluteToPath' :: Absolute -> Path'
fromAbsoluteSplit :: (Absolute, a) -> (Path, a)
fromList :: [NameSegment] -> Path
fromName :: Name -> Path
fromName' :: Name -> Path'
fromPath' :: Path' -> Path
fromText :: Text -> Path
toAbsoluteSplit :: Absolute -> (Path', a) -> (Absolute, a)
toList :: Path -> [NameSegment]
toName :: Path -> Name

-- | Convert a Path' to a Name
toName' :: Path' -> Name
toPath' :: Path -> Path'

-- | Note: This treats the path as relative.
toText :: Path -> Text
toText' :: Path' -> Text
unsplit :: Split -> Path
unsplit' :: Split' -> Path'
unsplitHQ :: HQSplit -> HashQualified Path
unsplitHQ' :: HQSplit' -> HashQualified Path'
splitFromName :: Name -> Maybe Split
hqSplitFromName' :: Name -> Maybe HQSplit'
cons :: NameSegment -> Path -> Path
snoc :: Path -> NameSegment -> Path
unsnoc :: Path -> Maybe (Path, NameSegment)
class Convert a b
convert :: Convert a b => a -> b
instance GHC.Base.Monoid Unison.Codebase.Path.Path
instance GHC.Base.Semigroup Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Path
instance GHC.Classes.Eq Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Absolute
instance GHC.Classes.Eq Unison.Codebase.Path.Absolute
instance GHC.Classes.Ord Unison.Codebase.Path.Relative
instance GHC.Classes.Eq Unison.Codebase.Path.Relative
instance GHC.Classes.Ord Unison.Codebase.Path.Path'
instance GHC.Classes.Eq Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Relative Unison.Codebase.Path.Absolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Split'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.HQSplit Unison.Codebase.Path.HQSplitAbsolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path' Unison.Codebase.Path.Absolute
instance Unison.Name.Convert Unison.Codebase.Path.HQSplit' (Unison.HashQualified'.HashQualified Unison.Codebase.Path.Path')
instance Unison.Name.Parse Unison.Name.Name Unison.Codebase.Path.HQSplit'
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Split' Unison.Codebase.Path.Split' Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.HQSplit (Unison.HashQualified'.HashQualified Unison.Codebase.Path.Path)
instance Unison.Name.Parse Unison.Name.Name Unison.Codebase.Path.Split
instance GHC.Show.Show Unison.Codebase.Path.Path'
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Path' Unison.Name.Name
instance GHC.Show.Show Unison.Codebase.Path.Relative
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Relative Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Codebase.Path.Relative GHC.Base.String
instance GHC.Show.Show Unison.Codebase.Path.Absolute
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert Unison.Codebase.Path.Absolute Data.Text.Internal.Text
instance Unison.Name.Convert Unison.Codebase.Path.Absolute GHC.Base.String
instance GHC.Show.Show Unison.Codebase.Path.Path
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.NameSegment Unison.NameSegment.NameSegment
instance Unison.Name.Convert [Unison.NameSegment.NameSegment] Unison.Codebase.Path.Path
instance Unison.Name.Convert Unison.Codebase.Path.Path [Unison.NameSegment.NameSegment]
instance Unison.Name.Convert Unison.Codebase.Path.Path Unison.Name.Name


-- | This module defines the <a>PushBehavior</a> type.
module Unison.Codebase.PushBehavior

-- | How a <tt>push</tt> behaves.
data PushBehavior

-- | The namespace being pushed to is required to be empty.
RequireEmpty :: PushBehavior

-- | The namespace being pushed to is required to be non-empty
RequireNonEmpty :: PushBehavior
instance GHC.Show.Show Unison.Codebase.PushBehavior.PushBehavior
instance GHC.Classes.Eq Unison.Codebase.PushBehavior.PushBehavior

module Unison.Codebase.Reflog
data Entry h
Entry :: h -> h -> Text -> Entry h
[from] :: Entry h -> h
[to] :: Entry h -> h
[reason] :: Entry h -> Text
fromText :: Coercible h Hash => Text -> Maybe (Entry h)
toText :: Coercible h Hash => Entry h -> Text

module Unison.Codebase.Serialization
type Get a = forall m. MonadGet m => m a
type Put a = forall m. MonadPut m => a -> m ()
data Format a
Format :: Get a -> Put a -> Format a
[get] :: Format a -> Get a
[put] :: Format a -> Put a
getFromBytes :: Get a -> ByteString -> Maybe a
getFromFile :: MonadIO m => Get a -> FilePath -> m (Maybe a)
getFromFile' :: MonadIO m => Get a -> FilePath -> m (Either String a)
putBytes :: Put a -> a -> ByteString
putWithParentDirs :: MonadIO m => Put a -> FilePath -> a -> m ()

module Unison.Codebase.ShortBranchHash
toString :: ShortBranchHash -> String
toHash :: Coercible Hash h => ShortBranchHash -> Maybe h
fromHash :: Coercible h Hash => Int -> h -> ShortBranchHash
fullFromHash :: Coercible h Hash => h -> ShortBranchHash
fromText :: Text -> Maybe ShortBranchHash
newtype ShortBranchHash
ShortBranchHash :: Text -> ShortBranchHash
[toText] :: ShortBranchHash -> Text
instance GHC.Generics.Generic Unison.Codebase.ShortBranchHash.ShortBranchHash
instance GHC.Classes.Ord Unison.Codebase.ShortBranchHash.ShortBranchHash
instance GHC.Classes.Eq Unison.Codebase.ShortBranchHash.ShortBranchHash
instance GHC.Show.Show Unison.Codebase.ShortBranchHash.ShortBranchHash

module Unison.Codebase.Editor.RemoteRepo
data ReadRepo
ReadGitRepo :: Text -> ReadRepo
[url] :: ReadRepo -> Text
data WriteRepo
WriteGitRepo :: Text -> WriteRepo
[url'] :: WriteRepo -> Text
writeToRead :: WriteRepo -> ReadRepo
writePathToRead :: WriteRemotePath -> ReadRemoteNamespace
printReadRepo :: ReadRepo -> Text
printWriteRepo :: WriteRepo -> Text
printNamespace :: ReadRepo -> Maybe ShortBranchHash -> Path -> Text
printHead :: WriteRepo -> Path -> Text
type ReadRemoteNamespace = (ReadRepo, Maybe ShortBranchHash, Path)
type WriteRemotePath = (WriteRepo, Path)
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadRepo
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ReadRepo
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadRepo
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.WriteRepo
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.WriteRepo
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.WriteRepo

module Unison.Codebase.GitError
type CodebasePath = FilePath
data GitProtocolError
NoGit :: GitProtocolError
UnrecognizableCacheDir :: ReadRepo -> CodebasePath -> GitProtocolError
UnrecognizableCheckoutDir :: ReadRepo -> CodebasePath -> GitProtocolError
CloneException :: ReadRepo -> String -> GitProtocolError
PushException :: WriteRepo -> String -> GitProtocolError
PushNoOp :: WriteRepo -> GitProtocolError
PushDestinationHasNewStuff :: WriteRepo -> GitProtocolError
CleanupError :: SomeException -> GitProtocolError
data GitCodebaseError h
NoRemoteNamespaceWithHash :: ReadRepo -> ShortBranchHash -> GitCodebaseError h
RemoteNamespaceHashAmbiguous :: ReadRepo -> ShortBranchHash -> Set h -> GitCodebaseError h
CouldntLoadRootBranch :: ReadRepo -> h -> GitCodebaseError h
CouldntLoadSyncedBranch :: ReadRemoteNamespace -> h -> GitCodebaseError h
CouldntFindRemoteBranch :: ReadRepo -> Path -> GitCodebaseError h
instance GHC.Show.Show Unison.Codebase.GitError.GitProtocolError
instance GHC.Show.Show h => GHC.Show.Show (Unison.Codebase.GitError.GitCodebaseError h)

module Unison.Codebase.SqliteCodebase.SyncEphemeral
data Dependencies
Dependencies :: Set Hash -> Set Hash -> Dependencies
[definitions] :: Dependencies -> Set Hash
[branches] :: Dependencies -> Set Hash
data Error
Sync22Error :: Error -> Error
SrcWrongSchema :: SchemaVersion -> Error
DestWrongSchema :: SchemaVersion -> Error
DisappearingBranch :: CausalHash -> Error
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.SyncEphemeral.Error

module Unison.Codebase.SyncMode
data SyncMode
ShortCircuit :: SyncMode
Complete :: SyncMode
instance GHC.Show.Show Unison.Codebase.SyncMode.SyncMode
instance GHC.Classes.Eq Unison.Codebase.SyncMode.SyncMode

module Unison.Codebase.TermEdit
data TermEdit
Replace :: Reference -> Typing -> TermEdit
Deprecate :: TermEdit
references :: TermEdit -> [Reference]
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
toReference :: TermEdit -> Maybe Reference
isTypePreserving :: TermEdit -> Bool
isSame :: TermEdit -> Bool
instance GHC.Show.Show Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Ord Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Eq Unison.Codebase.TermEdit.Typing
instance GHC.Show.Show Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Ord Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Eq Unison.Codebase.TermEdit.TermEdit
instance Unison.Hashable.Hashable Unison.Codebase.TermEdit.TermEdit
instance Unison.Hashable.Hashable Unison.Codebase.TermEdit.Typing

module Unison.Codebase.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
references :: TypeEdit -> [Reference]
toReference :: TypeEdit -> Maybe Reference
instance GHC.Show.Show Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Ord Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Eq Unison.Codebase.TypeEdit.TypeEdit
instance Unison.Hashable.Hashable Unison.Codebase.TypeEdit.TypeEdit

module Unison.Codebase.Patch
data Patch
Patch :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Patch
[_termEdits] :: Patch -> Relation Reference TermEdit
[_typeEdits] :: Patch -> Relation Reference TypeEdit
data PatchDiff
PatchDiff :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Relation Reference TermEdit -> Relation Reference TypeEdit -> PatchDiff
[_addedTermEdits] :: PatchDiff -> Relation Reference TermEdit
[_addedTypeEdits] :: PatchDiff -> Relation Reference TypeEdit
[_removedTermEdits] :: PatchDiff -> Relation Reference TermEdit
[_removedTypeEdits] :: PatchDiff -> Relation Reference TypeEdit
typeEdits :: Lens' Patch (Relation Reference TypeEdit)
termEdits :: Lens' Patch (Relation Reference TermEdit)
removedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
removedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
addedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
addedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
diff :: Patch -> Patch -> PatchDiff
labeledDependencies :: Patch -> Set LabeledDependency
empty :: Patch
isEmpty :: Patch -> Bool
allReferences :: Patch -> Set Reference

-- | Returns the set of references which are the target of an arrow in the
--   patch
allReferenceTargets :: Patch -> Set Reference
updateTerm :: (Reference -> Reference -> Typing) -> Reference -> TermEdit -> Patch -> Patch
updateType :: Reference -> TypeEdit -> Patch -> Patch
conflicts :: Patch -> Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.Patch
instance GHC.Base.Monoid Unison.Codebase.Patch.Patch
instance Unison.Hashable.Hashable Unison.Codebase.Patch.Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.PatchDiff
instance GHC.Base.Monoid Unison.Codebase.Patch.PatchDiff
instance GHC.Show.Show Unison.Codebase.Patch.Patch
instance GHC.Classes.Ord Unison.Codebase.Patch.Patch
instance GHC.Classes.Eq Unison.Codebase.Patch.Patch
instance GHC.Show.Show Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Ord Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Eq Unison.Codebase.Patch.PatchDiff

module Unison.Codebase.Verbosity
data Verbosity
Default :: Verbosity
Silent :: Verbosity
isSilent :: Verbosity -> Bool
instance GHC.Show.Show Unison.Codebase.Verbosity.Verbosity
instance GHC.Classes.Eq Unison.Codebase.Verbosity.Verbosity

module Unison.CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

module Unison.Codebase.SqliteCodebase.GitError
data GitSqliteCodebaseError
GitCouldntParseRootBranchHash :: ReadRepo -> String -> GitSqliteCodebaseError
NoDatabaseFile :: ReadRepo -> CodebasePath -> GitSqliteCodebaseError
UnrecognizedSchemaVersion :: ReadRepo -> CodebasePath -> SchemaVersion -> GitSqliteCodebaseError
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.GitError.GitSqliteCodebaseError

module Unison.Hashing.V2.Reference

-- | Either a builtin or a user defined (hashed) top-level declaration.
--   
--   Used for both terms and types. Doesn't distinguish between them.
--   
--   Other used defined things like local variables don't get
--   <tt>Reference</tt>s.
data Reference
pattern Builtin :: () => Text -> Reference
pattern Derived :: Hash -> Pos -> Size -> Reference
pattern DerivedId :: () => Id -> Reference

-- | <tt>Pos</tt> is a position into a cycle of size <tt>Size</tt>, as
--   cycles are hashed together.
data Id
Id :: Hash -> Pos -> Size -> Id
type Pos = Word64
type Size = Word64
derivedBase32Hex :: Text -> Pos -> Size -> Reference
data Component
members :: Component -> Set Reference
components :: [(Hash, [k])] -> [(k, Id)]
groupByComponent :: [(k, Reference)] -> [[(k, Reference)]]
componentFor :: Reference -> Component
unsafeFromText :: Text -> Reference
idFromText :: Text -> Maybe Id
isPrefixOf :: ShortHash -> Reference -> Bool
fromShortHash :: ShortHash -> Maybe Reference
fromText :: Text -> Either String Reference
readSuffix :: Text -> Either String (Pos, Size)
showShort :: Int -> Reference -> Text
showSuffix :: Pos -> Size -> Text
toId :: Reference -> Maybe Id
toText :: Reference -> Text
unsafeId :: Reference -> Id
toShortHash :: Reference -> ShortHash
idToShortHash :: Id -> ShortHash
instance GHC.Generics.Generic Unison.Hashing.V2.Reference.Id
instance GHC.Generics.Generic Unison.Hashing.V2.Reference.Reference
instance GHC.Classes.Ord Unison.Hashing.V2.Reference.Reference
instance GHC.Classes.Eq Unison.Hashing.V2.Reference.Reference
instance GHC.Show.Show Unison.Hashing.V2.Reference.Id
instance GHC.Show.Show Unison.Hashing.V2.Reference.Reference
instance Unison.Hashable.Hashable Unison.Hashing.V2.Reference.Reference
instance GHC.Classes.Eq Unison.Hashing.V2.Reference.Id
instance GHC.Classes.Ord Unison.Hashing.V2.Reference.Id

module Unison.Hashing.V2.Reference.Util
hashComponents :: (Functor f, Hashable1 f, Foldable f, Eq v, Show v, Var v) => (Id -> Term f v ()) -> Map v (Term f v a) -> Map v (Id, Term f v a)

module Unison.Hashing.V2.Referent

-- | Specifies a term.
--   
--   Either a term <a>Reference</a>, a data constructor, or an effect
--   constructor.
--   
--   Slightly odd naming. This is the "referent of term name in the
--   codebase", rather than the target of a Reference.
type Referent = Referent' Reference
type ConstructorId = Int
pattern Ref :: Reference -> Referent
pattern Con :: Reference -> ConstructorId -> ConstructorType -> Referent

-- | Cannot be a builtin.
type Id = Referent' Id
toShortHash :: Referent -> ShortHash
toShortHashId :: Id -> ShortHash
patternShortHash :: Reference -> ConstructorId -> ShortHash
showShort :: Int -> Referent -> Text
toText :: Referent -> Text
ctorTypeText :: ConstructorType -> Text
pattern EffectCtor :: (Eq a, IsString a) => a
pattern DataCtor :: (Eq a, IsString a) => a
toString :: Referent -> String
isConstructor :: Referent -> Bool
toTermReference :: Referent -> Maybe Reference
toReference :: Referent -> Reference
fromId :: Id -> Referent
toTypeReference :: Referent -> Maybe Reference
isPrefixOf :: ShortHash -> Referent -> Bool
unsafeFromText :: Text -> Referent
fromText :: Text -> Maybe Referent
fold :: (r -> a) -> (r -> ConstructorId -> ConstructorType -> a) -> Referent' r -> a

module Unison.Hashing.V2.LabeledDependency
derivedTerm :: Id -> LabeledDependency
derivedType :: Id -> LabeledDependency
termRef :: Reference -> LabeledDependency
typeRef :: Reference -> LabeledDependency
referent :: Referent -> LabeledDependency
dataConstructor :: Reference -> ConstructorId -> LabeledDependency
effectConstructor :: Reference -> ConstructorId -> LabeledDependency
fold :: (Reference -> a) -> (Referent -> a) -> LabeledDependency -> a
referents :: Foldable f => f Referent -> Set LabeledDependency

-- | Left TypeRef | Right TermRef
toReference :: LabeledDependency -> Either Reference Reference
data LabeledDependency
partition :: Foldable t => t LabeledDependency -> ([Reference], [Referent])
instance GHC.Show.Show Unison.Hashing.V2.LabeledDependency.LabeledDependency
instance GHC.Classes.Ord Unison.Hashing.V2.LabeledDependency.LabeledDependency
instance GHC.Classes.Eq Unison.Hashing.V2.LabeledDependency.LabeledDependency

module Unison.Hashing.V2.Type

-- | Types are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Type v a = Term F v a

-- | Base functor for types in the Unison language
data F a
Ref :: Reference -> F a
Arrow :: a -> a -> F a
Ann :: a -> Kind -> F a
App :: a -> a -> F a
Effect :: a -> a -> F a
Effects :: [a] -> F a
Forall :: a -> F a
IntroOuter :: a -> F a
bindExternal :: Var v => [(v, Reference)] -> Type v a -> Type v a
bindReferences :: Var v => Set v -> Map Name Reference -> Type v a -> ResolutionResult v a (Type v a)
dependencies :: Ord v => Type v a -> Set Reference
toReference :: (Var v, Show v) => Type v a -> Reference
toReferenceMentions :: (Var v, Show v) => Type v a -> Set Reference
booleanRef :: Reference
charRef :: Reference
effectRef :: Reference
floatRef :: Reference
intRef :: Reference
listRef :: Reference
natRef :: Reference
textRef :: Reference
instance Data.Traversable.Traversable Unison.Hashing.V2.Type.F
instance GHC.Base.Functor Unison.Hashing.V2.Type.F
instance Data.Foldable.Foldable Unison.Hashing.V2.Type.F
instance Unison.Hashable.Hashable1 Unison.Hashing.V2.Type.F

module Unison.Hashing.V2.Pattern
type ConstructorId = Int
data Pattern loc
Unbound :: loc -> Pattern loc
Var :: loc -> Pattern loc
Boolean :: loc -> !Bool -> Pattern loc
Int :: loc -> !Int64 -> Pattern loc
Nat :: loc -> !Word64 -> Pattern loc
Float :: loc -> !Double -> Pattern loc
Text :: loc -> !Text -> Pattern loc
Char :: loc -> !Char -> Pattern loc
Constructor :: loc -> !Reference -> !Int -> [Pattern loc] -> Pattern loc
As :: loc -> Pattern loc -> Pattern loc
EffectPure :: loc -> Pattern loc -> Pattern loc
EffectBind :: loc -> !Reference -> !Int -> [Pattern loc] -> Pattern loc -> Pattern loc
SequenceLiteral :: loc -> [Pattern loc] -> Pattern loc
SequenceOp :: loc -> Pattern loc -> !SeqOp -> Pattern loc -> Pattern loc
data SeqOp
Cons :: SeqOp
Snoc :: SeqOp
Concat :: SeqOp
application :: Pattern loc -> Bool
loc :: Pattern loc -> loc
setLoc :: Pattern loc -> loc -> Pattern loc
foldMap' :: Monoid m => (Pattern loc -> m) -> Pattern loc -> m
generalizedDependencies :: Ord r => (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> Pattern loc -> Set r
instance GHC.Generics.Generic Unison.Hashing.V2.Pattern.SeqOp
instance GHC.Classes.Ord Unison.Hashing.V2.Pattern.SeqOp
instance GHC.Show.Show Unison.Hashing.V2.Pattern.SeqOp
instance GHC.Classes.Eq Unison.Hashing.V2.Pattern.SeqOp
instance Data.Traversable.Traversable Unison.Hashing.V2.Pattern.Pattern
instance Data.Foldable.Foldable Unison.Hashing.V2.Pattern.Pattern
instance GHC.Base.Functor Unison.Hashing.V2.Pattern.Pattern
instance GHC.Generics.Generic (Unison.Hashing.V2.Pattern.Pattern loc)
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Hashing.V2.Pattern.Pattern loc)
instance GHC.Show.Show (Unison.Hashing.V2.Pattern.Pattern loc)
instance Unison.Hashable.Hashable (Unison.Hashing.V2.Pattern.Pattern p)
instance GHC.Classes.Eq (Unison.Hashing.V2.Pattern.Pattern loc)
instance Unison.Hashable.Hashable Unison.Hashing.V2.Pattern.SeqOp

module Unison.Hashing.V2.Term

-- | Like `Term v`, but with an annotation of type <tt>a</tt> at every
--   level in the tree
type Term v a = Term2 v a a v a

-- | Base functor for terms in the Unison language We need <tt>typeVar</tt>
--   because the term and type variables may differ.
data F typeVar typeAnn patternAnn a
Int :: Int64 -> F typeVar typeAnn patternAnn a
Nat :: Word64 -> F typeVar typeAnn patternAnn a
Float :: Double -> F typeVar typeAnn patternAnn a
Boolean :: Bool -> F typeVar typeAnn patternAnn a
Text :: Text -> F typeVar typeAnn patternAnn a
Char :: Char -> F typeVar typeAnn patternAnn a
Blank :: Blank typeAnn -> F typeVar typeAnn patternAnn a
Ref :: Reference -> F typeVar typeAnn patternAnn a
Constructor :: Reference -> ConstructorId -> F typeVar typeAnn patternAnn a
Request :: Reference -> ConstructorId -> F typeVar typeAnn patternAnn a
Handle :: a -> a -> F typeVar typeAnn patternAnn a
App :: a -> a -> F typeVar typeAnn patternAnn a
Ann :: a -> Type typeVar typeAnn -> F typeVar typeAnn patternAnn a
List :: Seq a -> F typeVar typeAnn patternAnn a
If :: a -> a -> a -> F typeVar typeAnn patternAnn a
And :: a -> a -> F typeVar typeAnn patternAnn a
Or :: a -> a -> F typeVar typeAnn patternAnn a
Lam :: a -> F typeVar typeAnn patternAnn a
LetRec :: IsTop -> [a] -> a -> F typeVar typeAnn patternAnn a
Let :: IsTop -> a -> a -> F typeVar typeAnn patternAnn a
Match :: a -> [MatchCase patternAnn a] -> F typeVar typeAnn patternAnn a
TermLink :: Referent -> F typeVar typeAnn patternAnn a
TypeLink :: Reference -> F typeVar typeAnn patternAnn a
data MatchCase loc a
MatchCase :: Pattern loc -> Maybe a -> a -> MatchCase loc a
hashComponents :: Var v => Map v (Term v a) -> Map v (Id, Term v a)
hashClosedTerm :: Var v => Term v a -> Id
instance Data.Traversable.Traversable (Unison.Hashing.V2.Term.MatchCase loc)
instance GHC.Generics.Generic1 (Unison.Hashing.V2.Term.MatchCase loc)
instance GHC.Generics.Generic (Unison.Hashing.V2.Term.MatchCase loc a)
instance GHC.Base.Functor (Unison.Hashing.V2.Term.MatchCase loc)
instance Data.Foldable.Foldable (Unison.Hashing.V2.Term.MatchCase loc)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Hashing.V2.Term.MatchCase loc a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Hashing.V2.Term.MatchCase loc a)
instance Data.Traversable.Traversable (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic1 (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn a)
instance GHC.Base.Functor (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance Data.Foldable.Foldable (Unison.Hashing.V2.Term.F typeVar typeAnn patternAnn)
instance Unison.Var.Var v => Unison.Hashable.Hashable1 (Unison.Hashing.V2.Term.F v a p)

module Unison.Hashing.V2.DataDeclaration
data DataDeclaration v a
DataDeclaration :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
[modifier] :: DataDeclaration v a -> Modifier
[annotation] :: DataDeclaration v a -> a
[bound] :: DataDeclaration v a -> [v]
[constructors'] :: DataDeclaration v a -> [(a, v, Type v a)]
newtype EffectDeclaration v a
EffectDeclaration :: DataDeclaration v a -> EffectDeclaration v a
[toDataDecl] :: EffectDeclaration v a -> DataDeclaration v a
type Decl v a = Either (EffectDeclaration v a) (DataDeclaration v a)
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier
asDataDecl :: Decl v a -> DataDeclaration v a
constructorType :: Decl v a -> ConstructorType
constructorTypes :: DataDeclaration v a -> [Type v a]
declDependencies :: Ord v => Decl v a -> Set Reference
dependencies :: Ord v => DataDeclaration v a -> Set Reference
bindReferences :: Var v => Set v -> Map Name Reference -> DataDeclaration v a -> ResolutionResult v a (DataDeclaration v a)

-- | compute the hashes of these user defined types and update any free
--   vars corresponding to these decls with the resulting hashes
--   
--   data List a = Nil | Cons a (List a) becomes something like (List,
--   #xyz, [forall a. #xyz a, forall a. a -&gt; (#xyz a) -&gt; (#xyz a)])
--   
--   NOTE: technical limitation, this implementation gives diff results if
--   ctors have the same FQN as one of the types. TODO: assert this and
--   bomb if not satisfied, or else do local mangling and unmangling to
--   ensure this doesn't affect the hash.
hashDecls :: (Eq v, Var v, Show v) => Map v (DataDeclaration v a) -> ResolutionResult v a [(v, Id, DataDeclaration v a)]
instance GHC.Show.Show Unison.Hashing.V2.DataDeclaration.Modifier
instance GHC.Classes.Ord Unison.Hashing.V2.DataDeclaration.Modifier
instance GHC.Classes.Eq Unison.Hashing.V2.DataDeclaration.Modifier
instance GHC.Base.Functor (Unison.Hashing.V2.DataDeclaration.DataDeclaration v)
instance GHC.Base.Functor (Unison.Hashing.V2.DataDeclaration.EffectDeclaration v)
instance Data.Foldable.Foldable Unison.Hashing.V2.DataDeclaration.F
instance GHC.Base.Functor Unison.Hashing.V2.DataDeclaration.F
instance Unison.Hashable.Hashable1 Unison.Hashing.V2.DataDeclaration.F
instance Unison.Hashable.Hashable Unison.Hashing.V2.DataDeclaration.Modifier

module Unison.Hashing.V2.Convert
type ResolutionResult v a r = Either Seq ResolutionFailure v a r
hashDecls :: Var v => Map v (DataDeclaration v a) -> ResolutionResult v a [(v, Id, DataDeclaration v a)]
hashClosedTerm :: Var v => Term v a -> Id
hashTermComponents :: Var v => Map v (Term v a) -> Map v (Id, Term v a)
typeToReference :: Var v => Type v a -> Reference
typeToReferenceMentions :: Var v => Type v a -> Set Reference

module Unison.Builtin.Decls
lookupDeclRef :: Text -> Reference
lookupEffectRef :: Text -> Reference
unitRef :: Reference
pairRef :: Reference
optionalRef :: Reference
eitherRef :: Reference
testResultRef :: Reference
linkRef :: Reference
docRef :: Reference
ioErrorRef :: Reference
stdHandleRef :: Reference
failureRef :: Reference
ioFailureRef :: Reference
tlsFailureRef :: Reference
exceptionRef :: Reference
tlsSignedCertRef :: Reference
tlsPrivateKeyRef :: Reference
isPropagatedRef :: Reference
isTestRef :: Reference
fileModeRef :: Reference
filePathRef :: Reference
bufferModeRef :: Reference
seekModeRef :: Reference
seqViewRef :: Reference
pairCtorRef :: Referent
unitCtorRef :: Referent
constructorId :: Reference -> Text -> Maybe Int
noneId :: ConstructorId
someId :: ConstructorId
okConstructorId :: ConstructorId
failConstructorId :: ConstructorId
docBlobId :: ConstructorId
docLinkId :: ConstructorId
docSignatureId :: ConstructorId
docSourceId :: ConstructorId
docEvaluateId :: ConstructorId
docJoinId :: ConstructorId
linkTermId :: ConstructorId
linkTypeId :: ConstructorId
eitherRightId :: ConstructorId
eitherLeftId :: ConstructorId
isPropagatedConstructorId :: ConstructorId
isTestConstructorId :: ConstructorId
bufferModeNoBufferingId :: ConstructorId
bufferModeLineBufferingId :: ConstructorId
bufferModeBlockBufferingId :: ConstructorId
bufferModeSizedBlockBufferingId :: ConstructorId
seqViewEmpty :: ConstructorId
seqViewElem :: ConstructorId
okConstructorReferent :: Referent
failConstructorReferent :: Referent

-- | parse some builtin data types, and resolve their free variables using
--   | builtinTypes' and those types defined herein
builtinDataDecls :: [(Symbol, Id, DataDeclaration Symbol ())]
builtinEffectDecls :: [(Symbol, Id, EffectDeclaration Symbol ())]
pattern UnitRef :: Reference
pattern PairRef :: Reference
pattern EitherRef :: Reference
pattern OptionalRef :: Reference
pattern OptionalNone' :: Term (F typeVar typeAnn patternAnn) v a
pattern OptionalSome' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern TupleType' :: Var v => [Type v a] -> Type v a
pattern TupleTerm' :: [Term2 vt at ap v a] -> Term2 vt at ap v a
pattern TuplePattern :: [Pattern loc] -> Pattern loc
pattern EitherLeft' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherRight' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherLeftId :: ConstructorId
pattern EitherRightId :: ConstructorId
unLeftTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
unRightTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
pattern DocRef :: Reference
pattern DocJoin :: Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term (F typeVar typeAnn patternAnn) v a
pattern DocBlob :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern DocLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocEvaluate :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc :: Term (F typeVar typeAnn patternAnn) v a
pattern DocSignatureId :: ConstructorId
pattern DocBlobId :: ConstructorId
pattern DocLinkId :: ConstructorId
pattern DocSourceId :: ConstructorId
pattern DocEvaluateId :: ConstructorId
pattern DocJoinId :: ConstructorId
pattern LinkTermId :: ConstructorId
pattern LinkTypeId :: ConstructorId
pattern LinkRef :: Reference
pattern LinkTerm :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern LinkType :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
unitType :: Ord v => a -> Type v a
pairType :: Ord v => a -> Type v a
optionalType :: Ord v => a -> Type v a
testResultType :: Ord v => a -> Type v a
eitherType :: Ord v => a -> Type v a
ioErrorType :: Ord v => a -> Type v a
fileModeType :: Ord v => a -> Type v a
filePathType :: Ord v => a -> Type v a
bufferModeType :: Ord v => a -> Type v a
seekModeType :: Ord v => a -> Type v a
stdHandleType :: Ord v => a -> Type v a
failureType :: Ord v => a -> Type v a
exceptionType :: Ord v => a -> Type v a
tlsSignedCertType :: Var v => a -> Type v a
unitTerm :: Var v => a -> Term v a
tupleConsTerm :: (Ord v, Semigroup a) => Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
tupleTerm :: (Var v, Monoid a) => [Term v a] -> Term v a
forceTerm :: Var v => a -> a -> Term v a -> Term v a
delayTerm :: Var v => a -> Term v a -> Term v a
unTupleTerm :: Term2 vt at ap v a -> Maybe [Term2 vt at ap v a]
unTupleType :: Var v => Type v a -> Maybe [Type v a]
unTuplePattern :: Pattern loc -> Maybe [Pattern loc]
unUnitRef :: Reference -> Bool
unPairRef :: Reference -> Bool
unOptionalRef :: Reference -> Bool

module Unison.Builtin.Terms
builtinTermsSrc :: a -> [(Symbol, Term Symbol a, Type Symbol a)]
v :: Var v => Text -> v
builtinTermsRef :: a -> Map Symbol Id

module Unison.Lexer.Pos
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
type Line = Int
type Column = Int
line :: Pos -> Line
column :: Pos -> Column
instance GHC.Classes.Ord Unison.Lexer.Pos.Pos
instance GHC.Classes.Eq Unison.Lexer.Pos.Pos
instance GHC.Show.Show Unison.Lexer.Pos.Pos
instance GHC.Base.Semigroup Unison.Lexer.Pos.Pos
instance GHC.Base.Monoid Unison.Lexer.Pos.Pos

module Unison.Parser.Ann
data Ann
Intrinsic :: Ann
External :: Ann
Ann :: Pos -> Pos -> Ann
[start] :: Ann -> Pos
[end] :: Ann -> Pos
startingLine :: Ann -> Maybe Line
instance GHC.Show.Show Unison.Parser.Ann.Ann
instance GHC.Classes.Ord Unison.Parser.Ann.Ann
instance GHC.Classes.Eq Unison.Parser.Ann.Ann
instance GHC.Base.Monoid Unison.Parser.Ann.Ann
instance GHC.Base.Semigroup Unison.Parser.Ann.Ann

module Unison.Codebase.BuiltinAnnotation
class BuiltinAnnotation a
builtinAnnotation :: BuiltinAnnotation a => a
instance Unison.Codebase.BuiltinAnnotation.BuiltinAnnotation Unison.Parser.Ann.Ann

module Unison.PrettyPrintEnv
data PrettyPrintEnv
PrettyPrintEnv :: (Referent -> Maybe (HashQualified Name)) -> (Reference -> Maybe (HashQualified Name)) -> PrettyPrintEnv
[terms] :: PrettyPrintEnv -> Referent -> Maybe (HashQualified Name)
[types] :: PrettyPrintEnv -> Reference -> Maybe (HashQualified Name)
patterns :: PrettyPrintEnv -> ConstructorReference -> Maybe (HashQualified Name)
patternName :: PrettyPrintEnv -> ConstructorReference -> HashQualified Name
termName :: PrettyPrintEnv -> Referent -> HashQualified Name
typeName :: PrettyPrintEnv -> Reference -> HashQualified Name

-- | Get a name for a LabeledDependency from the PPE.
labeledRefName :: PrettyPrintEnv -> LabeledDependency -> HashQualified Name
todoHashLength :: Int
instance GHC.Show.Show Unison.PrettyPrintEnv.PrettyPrintEnv
instance GHC.Base.Monoid Unison.PrettyPrintEnv.PrettyPrintEnv
instance GHC.Base.Semigroup Unison.PrettyPrintEnv.PrettyPrintEnv

module Unison.PrettyPrintEnv.FQN
type Imports = Map Name Suffix
type Prefix = [Text]
type Suffix = Text
elideFQN :: Imports -> HashQualified Name -> HashQualified Name

module Unison.PrettyPrintEnv.Names
fromNames :: Int -> NamesWithHistory -> PrettyPrintEnv
fromSuffixNames :: Int -> NamesWithHistory -> PrettyPrintEnv

module Unison.PrettyPrintEnvDecl
data PrettyPrintEnvDecl
PrettyPrintEnvDecl :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnvDecl
[unsuffixifiedPPE] :: PrettyPrintEnvDecl -> PrettyPrintEnv
[suffixifiedPPE] :: PrettyPrintEnvDecl -> PrettyPrintEnv
instance GHC.Show.Show Unison.PrettyPrintEnvDecl.PrettyPrintEnvDecl

module Unison.PrettyPrintEnv.Util
declarationPPE :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnv
declarationPPEDecl :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnvDecl

module Unison.PrettyPrintEnvDecl.Names
fromNamesDecl :: Int -> NamesWithHistory -> PrettyPrintEnvDecl

module Unison.Runtime.SparseVector
data SparseVector bits a
SparseVector :: !bits -> !Vector a -> SparseVector bits a
[indices] :: SparseVector bits a -> !bits
[elements] :: SparseVector bits a -> !Vector a
map :: (Unbox a, Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b
mask :: (Unbox a, FiniteBits bits) => bits -> SparseVector bits a -> SparseVector bits a
zipWith :: (Unbox a, Unbox b, Unbox c, FiniteBits bits) => (a -> b -> c) -> SparseVector bits a -> SparseVector bits b -> SparseVector bits c
_1 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits a
_2 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits b
unzip :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> (SparseVector bits a, SparseVector bits b)
choose :: (FiniteBits bits, Unbox a) => bits -> SparseVector bits a -> SparseVector bits a -> SparseVector bits a
merge :: (FiniteBits bits, Unbox a) => SparseVector bits a -> SparseVector bits a -> SparseVector bits a
eq :: a -> a -> Bool

module Unison.Runtime.Vector
data Vec a
[Scalar] :: a -> Vec a
[Vec] :: Unbox a => Vector a -> Vec a
[Pair] :: Vec a -> Vec b -> Vec (a, b)
[Choose] :: Vec Bool -> Vec a -> Vec a -> Vec a
[Mux] :: Vec Nat -> Vec (Vec a) -> Vec a
type Nat = Word64
mu :: Vec a -> Nat -> Maybe a
bound :: Nat -> Vec a -> Nat
toList :: Vec a -> [a]

module Unison.Server.SearchResult
data SearchResult
Tp :: TypeResult -> SearchResult
Tm :: TermResult -> SearchResult
data TermResult
TermResult :: HashQualified Name -> Referent -> Set (HashQualified Name) -> TermResult
[termName] :: TermResult -> HashQualified Name
[referent] :: TermResult -> Referent
[termAliases] :: TermResult -> Set (HashQualified Name)
data TypeResult
TypeResult :: HashQualified Name -> Reference -> Set (HashQualified Name) -> TypeResult
[typeName] :: TypeResult -> HashQualified Name
[reference] :: TypeResult -> Reference
[typeAliases] :: TypeResult -> Set (HashQualified Name)
pattern Tm' :: HashQualified Name -> Referent -> Set (HashQualified Name) -> SearchResult
pattern Tp' :: HashQualified Name -> Reference -> Set (HashQualified Name) -> SearchResult

-- | Construct a term search result from a primary name, referent, and set
--   of aliases.
termResult :: HashQualified Name -> Referent -> Set (HashQualified Name) -> SearchResult
termSearchResult :: Names -> Name -> Referent -> SearchResult

-- | Construct a type search result from a primary name, reference, and set
--   of aliases.
typeResult :: HashQualified Name -> Reference -> Set (HashQualified Name) -> SearchResult
typeSearchResult :: Names -> Name -> Reference -> SearchResult
name :: SearchResult -> HashQualified Name
aliases :: SearchResult -> Set (HashQualified Name)

-- | TypeResults yield a <a>Ref</a>
toReferent :: SearchResult -> Referent
truncateAliases :: Int -> SearchResult -> SearchResult

-- | You may want to sort this list differently afterward.
fromNames :: Names -> [SearchResult]
_fromNames :: Names -> [SearchResult]
instance GHC.Show.Show Unison.Server.SearchResult.TermResult
instance GHC.Classes.Ord Unison.Server.SearchResult.TermResult
instance GHC.Classes.Eq Unison.Server.SearchResult.TermResult
instance GHC.Show.Show Unison.Server.SearchResult.TypeResult
instance GHC.Classes.Ord Unison.Server.SearchResult.TypeResult
instance GHC.Classes.Eq Unison.Server.SearchResult.TypeResult
instance GHC.Show.Show Unison.Server.SearchResult.SearchResult
instance GHC.Classes.Ord Unison.Server.SearchResult.SearchResult
instance GHC.Classes.Eq Unison.Server.SearchResult.SearchResult

module Unison.Server.QueryResult
data QueryResult
QueryResult :: [HashQualified Name] -> [SearchResult] -> QueryResult
[misses] :: QueryResult -> [HashQualified Name]
[hits] :: QueryResult -> [SearchResult]

module Unison.Server.SearchResult'
data SearchResult' v a
Tm' :: TermResult' v a -> SearchResult' v a
Tp' :: TypeResult' v a -> SearchResult' v a
data TermResult' v a
TermResult' :: HashQualified Name -> Maybe (Type v a) -> Referent -> Set (HashQualified Name) -> TermResult' v a
data TypeResult' v a
TypeResult' :: HashQualified Name -> DisplayObject () (Decl v a) -> Reference -> Set (HashQualified Name) -> TypeResult' v a
pattern Tm :: HashQualified Name -> Maybe (Type v a) -> Referent -> Set (HashQualified Name) -> SearchResult' v a
pattern Tp :: HashQualified Name -> DisplayObject () (Decl v a) -> Reference -> Set (HashQualified Name) -> SearchResult' v a
tmReferent :: SearchResult' v a -> Maybe Referent
tpReference :: SearchResult' v a -> Maybe Reference
foldResult' :: (TermResult' v a -> b) -> (TypeResult' v a -> b) -> SearchResult' v a -> b
labeledDependencies :: Ord v => SearchResult' v a -> Set LabeledDependency
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.SearchResult'.TermResult' v a)
instance Unison.ABT.Var v => GHC.Classes.Eq (Unison.Server.SearchResult'.TermResult' v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Server.SearchResult'.TypeResult' v a)
instance (Unison.ABT.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Server.SearchResult'.TypeResult' v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Server.SearchResult'.SearchResult' v a)
instance (Unison.ABT.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Server.SearchResult'.SearchResult' v a)

module Unison.Typechecker.Components

-- | Algorithm for minimizing cycles of a `let rec`. This can improve
--   generalization during typechecking and may also be more efficient for
--   execution.
--   
--   For instance:
--   
--   minimize (let rec id x = x; g = id 42; y = id "hi" in g) ==&gt; Just
--   (let id x = x; g = id 42; y = id "hi" in g)
--   
--   Gets rid of the let rec and replaces it with an ordinary `let`, such
--   that <a>id</a> is suitably generalized.
--   
--   Fails on the left if there are duplicate definitions.
minimize :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Maybe (Term' vt v a))
minimize' :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Term' vt v a)

module Unison.Typechecker.TypeLookup
data TypeLookup v a
TypeLookup :: Map Reference (Type v a) -> Map Reference (DataDeclaration v a) -> Map Reference (EffectDeclaration v a) -> TypeLookup v a
[typeOfTerms] :: TypeLookup v a -> Map Reference (Type v a)
[dataDecls] :: TypeLookup v a -> Map Reference (DataDeclaration v a)
[effectDecls] :: TypeLookup v a -> Map Reference (EffectDeclaration v a)
typeOfReferent :: TypeLookup v a -> Referent -> Maybe (Type v a)
unsafeConstructorType :: TypeLookup v a -> Reference -> ConstructorType
constructorType :: TypeLookup v a -> Reference -> Maybe ConstructorType
typeOfDataConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfEffectConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfTerm :: TypeLookup v a -> Reference -> Maybe (Type v a)
typeOfTerm' :: TypeLookup v a -> Reference -> Either Reference (Type v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Semigroup (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Monoid (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Functor (Unison.Typechecker.TypeLookup.TypeLookup v)

module Unison.Builtin
codeLookup :: Applicative m => CodeLookup Symbol m Ann
constructorType :: Reference -> Maybe ConstructorType
names :: NamesWithHistory
names0 :: Names
builtinDataDecls :: [(Symbol, (Id, DataDeclaration))]
builtinEffectDecls :: [(Symbol, (Id, EffectDeclaration))]
builtinConstructorType :: Map Reference ConstructorType
builtinTypeDependents :: Reference -> Set Reference
builtinTypes :: [(Name, Reference)]
builtinTermsByType :: Relation Reference Referent
builtinTermsByTypeMention :: Relation Reference Referent
intrinsicTermReferences :: Set Reference
intrinsicTypeReferences :: Set Reference
isBuiltinType :: Reference -> Bool
typeOf :: a -> (Type -> a) -> Reference -> a
typeLookup :: TypeLookup Symbol Ann
termRefTypes :: Map Reference Type
instance GHC.Show.Show Unison.Builtin.BuiltinDSL

module Unison.Typechecker.TypeVar
data TypeVar b v
Universal :: v -> TypeVar b v
Existential :: b -> v -> TypeVar b v
underlying :: TypeVar b v -> v
liftType :: Ord v => Type v a -> Type (TypeVar b v) a
lowerType :: Ord v => Type (TypeVar b v) a -> Type v a
liftTerm :: Ord v => Term v a -> Term' (TypeVar b v) v a
lowerTerm :: Ord v => Term' (TypeVar b v) v a -> Term v a
instance GHC.Base.Functor (Unison.Typechecker.TypeVar.TypeVar b)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeVar.TypeVar b v)
instance Unison.ABT.Var v => Unison.ABT.Var (Unison.Typechecker.TypeVar.TypeVar b v)
instance Unison.Var.Var v => Unison.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)

module Unison.UnisonFile.Env
data Env v a
Env :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> Names -> Env v a
[datasId] :: Env v a -> Map v (Id, DataDeclaration v a)
[effectsId] :: Env v a -> Map v (Id, EffectDeclaration v a)
[names] :: Env v a -> Names
datas :: Env v a -> Map v (Reference, DataDeclaration v a)

module Unison.UnisonFile.Error
data Error v a
UnknownType :: v -> a -> Error v a
DupDataAndAbility :: v -> a -> a -> Error v a
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Ord v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.UnisonFile.Error.Error v a)

module Unison.UnisonFile.Type
data UnisonFile v a
UnisonFileId :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a
[dataDeclarationsId] :: UnisonFile v a -> Map v (Id, DataDeclaration v a)
[effectDeclarationsId] :: UnisonFile v a -> Map v (Id, EffectDeclaration v a)
[terms] :: UnisonFile v a -> [(v, Term v a)]
[watches] :: UnisonFile v a -> Map WatchKind [(v, Term v a)]
pattern UnisonFile :: Map v (Reference, DataDeclaration v a) -> Map v (Reference, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> Map v (Id, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[dataDeclarationsId'] :: TypecheckedUnisonFile v a -> Map v (Id, DataDeclaration v a)
[effectDeclarationsId'] :: TypecheckedUnisonFile v a -> Map v (Id, EffectDeclaration v a)
[topLevelComponents'] :: TypecheckedUnisonFile v a -> [[(v, Term v a, Type v a)]]
[watchComponents] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, Term v a, Type v a)])]
[hashTermsId] :: TypecheckedUnisonFile v a -> Map v (Id, Maybe WatchKind, Term v a, Type v a)
pattern TypecheckedUnisonFile :: Map v (Reference, DataDeclaration v a) -> Map v (Reference, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> Map v (Reference, Maybe WatchKind, Term (F v a a) v a, Term F v a) -> TypecheckedUnisonFile v a
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.UnisonFile.Type.UnisonFile v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Classes.Ord v => GHC.Base.Functor (Unison.UnisonFile.Type.TypecheckedUnisonFile v)

module Unison.UnisonFile
data UnisonFile v a
UnisonFileId :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a
[dataDeclarationsId] :: UnisonFile v a -> Map v (Id, DataDeclaration v a)
[effectDeclarationsId] :: UnisonFile v a -> Map v (Id, EffectDeclaration v a)
[terms] :: UnisonFile v a -> [(v, Term v a)]
[watches] :: UnisonFile v a -> Map WatchKind [(v, Term v a)]
pattern UnisonFile :: Map v (Reference, DataDeclaration v a) -> Map v (Reference, EffectDeclaration v a) -> [(v, Term v a)] -> Map WatchKind [(v, Term v a)] -> UnisonFile v a
allWatches :: UnisonFile v a -> [(v, Term v a)]
dataDeclarations :: UnisonFile v a -> Map v (Reference, DataDeclaration v a)
declsToTypeLookup :: Var v => UnisonFile v a -> TypeLookup v a
dependencies :: (Monoid a, Var v) => UnisonFile v a -> Set Reference
effectDeclarations :: UnisonFile v a -> Map v (Reference, EffectDeclaration v a)
typecheckingTerm :: (Var v, Monoid a) => UnisonFile v a -> Term v a
watchesOfKind :: WatchKind -> UnisonFile v a -> [(v, Term v a)]

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> Map v (Id, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[dataDeclarationsId'] :: TypecheckedUnisonFile v a -> Map v (Id, DataDeclaration v a)
[effectDeclarationsId'] :: TypecheckedUnisonFile v a -> Map v (Id, EffectDeclaration v a)
[topLevelComponents'] :: TypecheckedUnisonFile v a -> [[(v, Term v a, Type v a)]]
[watchComponents] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, Term v a, Type v a)])]
[hashTermsId] :: TypecheckedUnisonFile v a -> Map v (Id, Maybe WatchKind, Term v a, Type v a)
allTerms :: Ord v => TypecheckedUnisonFile v a -> Map v (Term v a)
dataDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, DataDeclaration v a)
discardTypes :: TypecheckedUnisonFile v a -> UnisonFile v a
effectDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, EffectDeclaration v a)
hashConstructors :: forall v a. Ord v => TypecheckedUnisonFile v a -> Map v Id
hashTerms :: TypecheckedUnisonFile v a -> Map v (Reference, Maybe WatchKind, Term v a, Type v a)
indexByReference :: TypecheckedUnisonFile v a -> (Map Id (Term v a, Type v a), Map Id (Decl v a))
lookupDecl :: Ord v => v -> TypecheckedUnisonFile v a -> Maybe (Id, Decl v a)
nonEmpty :: TypecheckedUnisonFile v a -> Bool
termSignatureExternalLabeledDependencies :: Ord v => TypecheckedUnisonFile v a -> Set LabeledDependency

-- | the top level components (no watches) plus test watches.
topLevelComponents :: TypecheckedUnisonFile v a -> [[(v, Term v a, Type v a)]]
typecheckedUnisonFile :: forall v a. Var v => Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [[(v, Term v a, Type v a)]] -> [(WatchKind, [(v, Term v a, Type v a)])] -> TypecheckedUnisonFile v a

module Unison.UnisonFile.Names
toNames :: Var v => UnisonFile v a -> Names
typecheckedToNames :: Var v => TypecheckedUnisonFile v a -> Names
typecheckedUnisonFile0 :: Ord v => TypecheckedUnisonFile v a
bindNames :: Var v => Names -> UnisonFile v a -> ResolutionResult v a (UnisonFile v a)
environmentFor :: forall v a. Var v => Names -> Map v (DataDeclaration v a) -> Map v (EffectDeclaration v a) -> ResolutionResult v a (Either [Error v a] (Env v a))

module Unison.Codebase.CodeLookup.Util
fromTypecheckedUnisonFile :: forall m v a. (Var v, Monad m) => TypecheckedUnisonFile v a -> CodeLookup v m a

module Unison.Util.Convert
class Convert a b
convert :: Convert a b => a -> b
class Parse a b
parse :: Parse a b => a -> Maybe b
instance (Unison.Util.Convert.Parse a a2, Unison.Util.Convert.Parse b b2) => Unison.Util.Convert.Parse (a, b) (a2, b2)

module Unison.Util.CycleTable
data CycleTable k v
CycleTable :: BasicHashTable k v -> IOPRef Int -> CycleTable k v
[table] :: CycleTable k v -> BasicHashTable k v
[sizeRef] :: CycleTable k v -> IOPRef Int
new :: Int -> IO (CycleTable k v)
lookup :: (Hashable k, Eq k) => k -> CycleTable k v -> IO (Maybe v)
insert :: (Hashable k, Eq k) => k -> v -> CycleTable k v -> IO ()
size :: CycleTable k v -> IO Int
insertEnd :: (Hashable k, Eq k) => k -> CycleTable k Int -> IO ()

module Unison.Util.CyclicEq
class CyclicEq a
cyclicEq :: CyclicEq a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Bool
bothEq' :: (Eq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
bothEq :: (CyclicEq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq [a]
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Vector.Vector a)

module Unison.Util.CyclicOrd
class CyclicOrd a
cyclicOrd :: CyclicOrd a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Ordering
bothOrd' :: (Ord a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
bothOrd :: (CyclicOrd a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd [a]
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Vector.Vector a)

module Unison.Util.EnumContainers
data EnumMap k a
data EnumSet k
class EnumKey k
keyToInt :: EnumKey k => k -> Int
intToKey :: EnumKey k => Int -> k
mapFromList :: EnumKey k => [(k, a)] -> EnumMap k a
setFromList :: EnumKey k => [k] -> EnumSet k
setToList :: EnumKey k => EnumSet k -> [k]
mapSingleton :: EnumKey k => k -> a -> EnumMap k a
setSingleton :: EnumKey k => k -> EnumSet k
mapInsert :: EnumKey k => k -> a -> EnumMap k a -> EnumMap k a
unionWith :: EnumKey k => EnumKey k => (a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
hasKey :: EnumKey k => k -> EnumMap k a -> Bool
keys :: EnumKey k => EnumMap k a -> [k]
keysSet :: EnumKey k => EnumMap k a -> EnumSet k
restrictKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
withoutKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
member :: EnumKey k => k -> EnumSet k -> Bool
lookup :: EnumKey k => k -> EnumMap k a -> Maybe a
lookupWithDefault :: EnumKey k => a -> k -> EnumMap k a -> a
mapWithKey :: EnumKey k => (k -> a -> b) -> EnumMap k a -> EnumMap k b
foldMapWithKey :: EnumKey k => Monoid m => (k -> a -> m) -> EnumMap k a -> m
mapToList :: EnumKey k => EnumMap k a -> [(k, a)]
(!) :: EnumKey k => EnumMap k a -> k -> a
findMin :: EnumKey k => EnumSet k -> k
traverseSet_ :: Applicative f => EnumKey k => (k -> f ()) -> EnumSet k -> f ()
setSize :: EnumSet k -> Int
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.EnumContainers.EnumMap k a)
instance Data.Traversable.Traversable (Unison.Util.EnumContainers.EnumMap k)
instance Data.Foldable.Foldable (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Functor (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Ord (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Eq (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Show.Show (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumSet k)
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word64
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word16

module Unison.Util.Exception
tryAny :: MonadIO m => IO a -> m (Either SomeException a)
catchAny :: IO a -> (SomeException -> IO a) -> IO a

module Unison.Codebase.Editor.Git
gitIn :: MonadIO m => FilePath -> [Text] -> m ()
gitTextIn :: MonadIO m => FilePath -> [Text] -> m Text

-- | Given a remote git repo url, and branch/commit hash (currently not
--   allowed): checks for git, clones or updates a cached copy of the repo
pullBranch :: (MonadIO m, MonadError GitProtocolError m) => ReadRepo -> m CodebasePath

-- | Perform an IO action, passing any IO exception to <tt>handler</tt>
withIOError :: MonadIO m => IO a -> (IOException -> m a) -> m a
withStatus :: MonadIO m => String -> m a -> m a

module Unison.Util.Free
data Free f a
Pure :: a -> Free f a
Bind :: f x -> (x -> Free f a) -> Free f a
eval :: f a -> Free f a
fold :: Monad m => (forall x. f x -> m x) -> Free f a -> m a
unfold :: (v -> Either a (f v)) -> v -> Free f a
unfold' :: (v -> Free f (Either a v)) -> v -> Free f a
unfoldM :: (Traversable f, Applicative m, Monad m) => (b -> m (Either a (f b))) -> b -> m (Free f a)
free :: Traversable f => f (Free f a) -> Free f a
foldWithIndex :: forall f m a. Monad m => (forall x. Int -> f x -> m x) -> Free f a -> m a
instance GHC.Base.Functor (Unison.Util.Free.Free f)
instance GHC.Base.Monad (Unison.Util.Free.Free f)
instance GHC.Base.Applicative (Unison.Util.Free.Free f)
instance Control.Monad.Trans.Class.MonadTrans Unison.Util.Free.Free

module Unison.Util.Less
less :: String -> IO ()


-- | Small logging library. Typical usage, import qualified:
--   
--   import qualified Unison.Util.Logger as L
--   
--   do logger &lt;- L.atomic . L.atInfo . L.scope "worker" . L.toHandle $
--   stderr L.warn logger "WARNING!!!" L.debug logger "Debug message, will
--   be ignored" let logger2 = L.atDebug logger L.debug logger2 "Debug
--   message, will be printed" logger' &lt;- L.at L.warnLevel
module Unison.Util.Logger
type Level = Int
type Scope = [String]
data Logger
Logger :: !Scope -> (String -> String) -> !Level -> (String -> IO ()) -> Logger
[getScope] :: Logger -> !Scope
[prefix] :: Logger -> String -> String
[getLevel] :: Logger -> !Level
[raw] :: Logger -> String -> IO ()

-- | Ensure at most one message is logged at the same time
atomic :: Logger -> IO Logger
toHandle :: Handle -> Logger
toStandardError :: Logger
toStandardOut :: Logger
logHandleAt :: Logger -> Level -> Handle -> IO ()
logAt' :: Logger -> Level -> IO String -> IO ()
logAt :: Logger -> Level -> String -> IO ()
scope :: String -> Logger -> Logger
scope' :: [String] -> Logger -> Logger
logger :: (String -> IO ()) -> Logger
error :: Logger -> String -> IO ()
warn :: Logger -> String -> IO ()
info :: Logger -> String -> IO ()
debug :: Logger -> String -> IO ()
trace :: Logger -> String -> IO ()
error' :: Logger -> IO String -> IO ()
warn' :: Logger -> IO String -> IO ()
info' :: Logger -> IO String -> IO ()
debug' :: Logger -> IO String -> IO ()
trace' :: Logger -> IO String -> IO ()
errorLevel :: Level
warnLevel :: Level
infoLevel :: Level
debugLevel :: Level
traceLevel :: Level
at :: Level -> Logger -> Logger
atError :: Logger -> Logger
atWarn :: Logger -> Logger
atInfo :: Logger -> Logger
atDebug :: Logger -> Logger
atTrace :: Logger -> Logger
increment :: Logger -> Logger
decrement :: Logger -> Logger


-- | A utility type for saving memory in the presence of many duplicate
--   ByteStrings, etc. If you have data that may be a redundant duplicate,
--   try pinning it to a pin board, and use the result of that operation
--   instead.
--   
--   Without a pin board:
--   
--   x â”€â”€â”€â”€â”€ "38dce848c8c829c62" y â”€â”€â”€â”€â”€ "38dce848c8c829c62" z â”€â”€â”€â”€â”€
--   "d2518f260535b927b"
--   
--   With a pin board:
--   
--   x â”€â”€â”€â”€â”€ "38dce848c8c829c62" â”„â”„â”„â”„â”„â” y â”€â”€â”€â”€â”€â”€â”€â”€â”˜ board z â”€â”€â”€â”€â”€
--   "d2518f260535b927b" â”„â”„â”„â”„â”„â”˜
--   
--   ... and after x is garbage collected:
--   
--   "38dce848c8c829c62" â”„â”„â”„â”„â”„â” y â”€â”€â”€â”€â”€â”€â”€â”€â”˜ board z â”€â”€â”€â”€â”€
--   "d2518f260535b927b" â”„â”„â”„â”„â”„â”˜
--   
--   ... and after y is garbage collected:
--   
--   board z â”€â”€â”€â”€â”€ "d2518f260535b927b" â”„â”„â”„â”„â”„â”˜
module Unison.Util.PinBoard

-- | A "pin board" is a place to pin values; semantically, it's a set, but
--   differs in a few ways:
--   
--   <ul>
--   <li>Pinned values aren't kept alive by the pin board, they might be
--   garbage collected at any time.</li>
--   <li>If you try to pin a value that's already pinned (per its Eq
--   instance), the pinned one will be returned instead.</li>
--   <li>It has a small API: just <a>new</a> and <a>pin</a>.</li>
--   </ul>
data PinBoard a
new :: MonadIO m => m (PinBoard a)
pin :: forall a m. (Eq a, Hashable a, MonadIO m) => PinBoard a -> a -> m a
debugDump :: MonadIO m => (a -> Text) -> PinBoard a -> m ()
debugSize :: PinBoard a -> IO Int

module Unison.Util.Range

-- | True if <tt>_x</tt> contains <tt>_y</tt>
contains :: Range -> Range -> Bool
overlaps :: Range -> Range -> Bool
inRange :: Pos -> Range -> Bool
isMultiLine :: Range -> Bool
data Range
Range :: Pos -> Pos -> Range
[start] :: Range -> Pos
[end] :: Range -> Pos
startingLine :: Range -> Range
instance GHC.Show.Show Unison.Util.Range.Range
instance GHC.Classes.Ord Unison.Util.Range.Range
instance GHC.Classes.Eq Unison.Util.Range.Range
instance GHC.Base.Semigroup Unison.Util.Range.Range

module Unison.Util.AnnotatedText
data Segment a
Segment :: String -> Maybe a -> Segment a
[segment] :: Segment a -> String
[annotation] :: Segment a -> Maybe a
toPair :: Segment a -> (String, Maybe a)
newtype AnnotatedText a
AnnotatedText :: Seq (Segment a) -> AnnotatedText a
data AnnotatedExcerpt a
AnnotatedExcerpt :: Line -> String -> Map Range a -> AnnotatedExcerpt a
[lineOffset] :: AnnotatedExcerpt a -> Line
[text] :: AnnotatedExcerpt a -> String
[annotations] :: AnnotatedExcerpt a -> Map Range a
annotate' :: Maybe b -> AnnotatedText a -> AnnotatedText b
deannotate :: AnnotatedText a -> AnnotatedText b
annotate :: a -> AnnotatedText a -> AnnotatedText a
annotateMaybe :: AnnotatedText (Maybe a) -> AnnotatedText a
trailingNewLine :: AnnotatedText a -> Bool
markup :: AnnotatedExcerpt a -> Map Range a -> AnnotatedExcerpt a
textLength :: AnnotatedText a -> Int
textEmpty :: AnnotatedText a -> Bool
condensedExcerptToText :: Int -> AnnotatedExcerpt a -> AnnotatedText a
excerptToText :: forall a. AnnotatedExcerpt a -> AnnotatedText a
snipWithContext :: Int -> AnnotatedExcerpt a -> [AnnotatedExcerpt a]
instance GHC.Generics.Generic (Unison.Util.AnnotatedText.Segment a)
instance Data.Foldable.Foldable Unison.Util.AnnotatedText.Segment
instance GHC.Base.Functor Unison.Util.AnnotatedText.Segment
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.AnnotatedText.Segment a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.AnnotatedText.Segment a)
instance GHC.Generics.Generic (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.AnnotatedText.AnnotatedText a)
instance Data.Foldable.Foldable Unison.Util.AnnotatedText.AnnotatedText
instance GHC.Base.Functor Unison.Util.AnnotatedText.AnnotatedText
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Base.Functor Unison.Util.AnnotatedText.AnnotatedExcerpt
instance Data.String.IsString (Unison.Util.AnnotatedText.AnnotatedExcerpt a)
instance GHC.Base.Semigroup (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Base.Monoid (Unison.Util.AnnotatedText.AnnotatedText a)
instance Data.ListLike.FoldableLL.FoldableLL (Unison.Util.AnnotatedText.AnnotatedText a) GHC.Types.Char
instance Data.ListLike.Base.ListLike (Unison.Util.AnnotatedText.AnnotatedText a) GHC.Types.Char
instance Data.String.IsString (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Exts.IsList (Unison.Util.AnnotatedText.AnnotatedText a)

module Unison.Util.Rope
chunks :: Rope a -> [a]
singleton :: Sized a => a -> Rope a
one :: Sized a => a -> Rope a
map :: Sized b => (a -> b) -> Rope a -> Rope b
traverse :: (Applicative f, Sized b) => (a -> f b) -> Rope a -> f (Rope b)
null :: Sized a => Rope a -> Bool
flatten :: Monoid a => Rope a -> a
two :: Sized a => Rope a -> Rope a -> Rope a
cons :: (Sized a, Semigroup a) => a -> Rope a -> Rope a
uncons :: Sized a => Rope a -> Maybe (a, Rope a)
snoc :: (Sized a, Semigroup a) => Rope a -> a -> Rope a
unsnoc :: Sized a => Rope a -> Maybe (Rope a, a)
index :: (Sized a, Index a ch) => Int -> Rope a -> Maybe ch
debugDepth :: Rope a -> Int
class Sized a
size :: Sized a => a -> Int
class Take a
take :: Take a => Int -> a -> a
class Drop a
drop :: Drop a => Int -> a -> a
class Reverse a
reverse :: Reverse a => a -> a
class Index a elem
unsafeIndex :: Index a elem => Int -> a -> elem

-- | Roughly size-balanced binary tree of chunks. There are a few
--   operations that are sloppier about rebalancing as long as that can't
--   lead to trees of more than logarithmic depth.
--   
--   The <a>Int</a> in the <a>Two</a> constructor is a cached size of that
--   subtree.
data Rope a
instance Data.Foldable.Foldable Unison.Util.Rope.Rope
instance Unison.Util.Rope.Reverse a => Unison.Util.Rope.Reverse (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, Unison.Util.Rope.Index a ch) => Unison.Util.Rope.Index (Unison.Util.Rope.Rope a) ch
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a, Unison.Util.Rope.Drop a) => Unison.Util.Rope.Drop (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, Unison.Util.Rope.Take a, Unison.Util.Rope.Drop a, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, Unison.Util.Rope.Take a, Unison.Util.Rope.Drop a, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a, Unison.Util.Rope.Take a) => Unison.Util.Rope.Take (Unison.Util.Rope.Rope a)
instance Unison.Util.Rope.Sized a => Unison.Util.Rope.Sized (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a) => GHC.Base.Monoid (Unison.Util.Rope.Rope a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Unison.Util.Rope.Rope a)

module Unison.Util.Bytes
newtype Bytes
Bytes :: Rope Chunk -> Bytes
[underlying] :: Bytes -> Rope Chunk
type Chunk = Vector Word8
fromByteString :: ByteString -> Bytes
toByteString :: Bytes -> ByteString
fromWord8s :: [Word8] -> Bytes
toWord8s :: Bytes -> [Word8]
fromBase16 :: Bytes -> Either Text Bytes
toBase16 :: Bytes -> Bytes
fromBase32 :: Bytes -> Either Text Bytes
toBase32 :: Bytes -> Bytes
fromBase64 :: Bytes -> Either Text Bytes
toBase64 :: Bytes -> Bytes
fromBase64UrlUnpadded :: Bytes -> Either Text Bytes
toBase64UrlUnpadded :: Bytes -> Bytes
chunkFromByteString :: ByteString -> Chunk
byteStringToChunk :: ByteString -> Chunk
chunkToByteString :: Chunk -> ByteString
fromChunks :: [Chunk] -> Bytes
chunks :: Bytes -> [Chunk]
byteStringChunks :: Bytes -> [ByteString]
toArray :: ByteArray b => Bytes -> b
fromArray :: ByteArrayAccess b => b -> Bytes
toLazyByteString :: Bytes -> ByteString
flatten :: Bytes -> Bytes
at :: Int -> Bytes -> Maybe Word8
take :: Int -> Bytes -> Bytes
drop :: Int -> Bytes -> Bytes
size :: Bytes -> Int
empty :: Bytes
encodeNat16be :: Word64 -> Bytes
decodeNat16be :: Bytes -> Maybe (Word64, Bytes)
encodeNat32be :: Word64 -> Bytes
decodeNat32be :: Bytes -> Maybe (Word64, Bytes)
encodeNat64be :: Word64 -> Bytes
decodeNat64be :: Bytes -> Maybe (Word64, Bytes)
encodeNat16le :: Word64 -> Bytes
decodeNat16le :: Bytes -> Maybe (Word64, Bytes)
encodeNat32le :: Word64 -> Bytes
decodeNat32le :: Bytes -> Maybe (Word64, Bytes)
encodeNat64le :: Word64 -> Bytes
decodeNat64le :: Bytes -> Maybe (Word64, Bytes)

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text that is known
--   to be valid.
--   
--   If the input contains any invalid UTF-8 data, an exception will be
--   thrown that cannot be caught in pure code. For more control over the
--   handling of invalid data, use <a>decodeUtf8'</a> or
--   <a>decodeUtf8With</a>.
decodeUtf8 :: ByteString -> Text

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString
zlibCompress :: Bytes -> Bytes
zlibDecompress :: Bytes -> Bytes
gzipCompress :: Bytes -> Bytes
gzipDecompress :: Bytes -> Bytes
instance GHC.Classes.Ord Unison.Util.Bytes.Bytes
instance GHC.Classes.Eq Unison.Util.Bytes.Bytes
instance GHC.Base.Monoid Unison.Util.Bytes.Bytes
instance GHC.Base.Semigroup Unison.Util.Bytes.Bytes
instance Control.DeepSeq.NFData Unison.Util.Bytes.Bytes
instance GHC.Show.Show Unison.Util.Bytes.Bytes
instance Unison.Util.Rope.Sized Unison.Util.Bytes.Chunk
instance Unison.Util.Rope.Drop Unison.Util.Bytes.Chunk
instance Unison.Util.Rope.Take Unison.Util.Bytes.Chunk
instance Unison.Util.Rope.Index Unison.Util.Bytes.Chunk GHC.Word.Word8
instance Unison.Util.Rope.Reverse Unison.Util.Bytes.Chunk

module Unison.Lexer
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[payload] :: Token a -> a
[start] :: Token a -> !Pos
[end] :: Token a -> !Pos
type Line = Int
type Column = Int
data Err
InvalidWordyId :: String -> Err
InvalidSymbolyId :: String -> Err
InvalidShortHash :: String -> Err
InvalidBytesLiteral :: String -> Err
InvalidHexLiteral :: Err
InvalidOctalLiteral :: Err
Both :: Err -> Err -> Err
MissingFractional :: String -> Err
MissingExponent :: String -> Err
UnknownLexeme :: Err
TextLiteralMissingClosingQuote :: String -> Err
InvalidEscapeCharacter :: Char -> Err
LayoutError :: Err
CloseWithoutMatchingOpen :: String -> String -> Err
UnexpectedDelimiter :: String -> Err
Opaque :: String -> Err
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
data Lexeme
Open :: String -> Lexeme
Semi :: IsVirtual -> Lexeme
Close :: Lexeme
Reserved :: String -> Lexeme
Textual :: String -> Lexeme
Character :: Char -> Lexeme
Backticks :: String -> Maybe ShortHash -> Lexeme
WordyId :: String -> Maybe ShortHash -> Lexeme
SymbolyId :: String -> Maybe ShortHash -> Lexeme
Blank :: String -> Lexeme
Numeric :: String -> Lexeme
Bytes :: Bytes -> Lexeme
Hash :: ShortHash -> Lexeme
Err :: Err -> Lexeme
lexer :: String -> String -> [Token Lexeme]
simpleWordyId :: String -> Lexeme
simpleSymbolyId :: String -> Lexeme
line :: Pos -> Line
column :: Pos -> Column
escapeChars :: [(Char, Char)]
debugFileLex :: String -> IO ()
debugLex' :: String -> String
debugLex'' :: [Token Lexeme] -> String
debugLex''' :: String -> String -> String
showEscapeChar :: Char -> Maybe Char
touches :: Token a -> Token b -> Bool
typeModifiers :: Set String
typeOrAbilityAlt :: Alternative f => (String -> f a) -> f a
typeModifiersAlt :: Alternative f => (String -> f a) -> f a
wordyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
wordyId :: String -> Either Err (String, String)
symbolyId :: String -> Either Err (String, String)
wordyId0 :: String -> Either Err (String, String)
symbolyId0 :: String -> Either Err (String, String)
instance Data.Traversable.Traversable Unison.Lexer.T
instance Data.Foldable.Foldable Unison.Lexer.T
instance GHC.Base.Functor Unison.Lexer.T
instance GHC.Show.Show a => GHC.Show.Show (Unison.Lexer.T a)
instance Text.Megaparsec.Error.ShowErrorComponent (Unison.Lexer.Token Unison.Lexer.Err)
instance Text.Megaparsec.Error.ShowToken (Unison.Lexer.Token Unison.Lexer.Lexeme)
instance GHC.Base.Applicative Unison.Lexer.Token
instance GHC.Base.Functor Unison.Lexer.Token
instance GHC.Show.Show a => GHC.Show.Show (Unison.Lexer.Token a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Lexer.Token a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Lexer.Token a)
instance GHC.Show.Show Unison.Lexer.ParsingEnv
instance GHC.Show.Show Unison.Lexer.Err
instance GHC.Classes.Ord Unison.Lexer.Err
instance GHC.Classes.Eq Unison.Lexer.Err
instance GHC.Classes.Ord Unison.Lexer.Lexeme
instance GHC.Show.Show Unison.Lexer.Lexeme
instance GHC.Classes.Eq Unison.Lexer.Lexeme

module Unison.Parser
debug :: Bool
type P v = ParsecT (Error v) Input ((->) ParsingEnv)
type Token s = Token s
type Err v = ParseError (Token Input) (Error v)
data ParsingEnv
ParsingEnv :: UniqueName -> NamesWithHistory -> ParsingEnv
[uniqueNames] :: ParsingEnv -> UniqueName
[names] :: ParsingEnv -> NamesWithHistory
newtype UniqueName
UniqueName :: (Pos -> Int -> Maybe Text) -> UniqueName
uniqueBase32Namegen :: forall gen. DRG gen => gen -> UniqueName
uniqueName :: Var v => Int -> P v Text
data Error v
SignatureNeedsAccompanyingBody :: Token v -> Error v
DisallowedAbsoluteName :: Token Name -> Error v
EmptyBlock :: Token String -> Error v
UnknownAbilityConstructor :: Token (HashQualified Name) -> Set ConstructorReference -> Error v
UnknownDataConstructor :: Token (HashQualified Name) -> Set ConstructorReference -> Error v
UnknownTerm :: Token (HashQualified Name) -> Set Referent -> Error v
UnknownType :: Token (HashQualified Name) -> Set Reference -> Error v
UnknownId :: Token (HashQualified Name) -> Set Referent -> Set Reference -> Error v
ExpectedBlockOpen :: String -> Token Lexeme -> Error v
EmptyMatch :: Error v
EmptyWatch :: Error v
UseInvalidPrefixSuffix :: Either (Token Name) (Token Name) -> Maybe [Token Name] -> Error v
UseEmpty :: Token String -> Error v
DidntExpectExpression :: Token Lexeme -> Maybe (Token Lexeme) -> Error v
TypeDeclarationErrors :: [Error v Ann] -> Error v
MissingTypeModifier :: Token String -> Token v -> Error v
ResolutionFailures :: [ResolutionFailure v Ann] -> Error v
DuplicateTypeNames :: [(v, [Ann])] -> Error v
DuplicateTermNames :: [(v, [Ann])] -> Error v
PatternArityMismatch :: Int -> Int -> Ann -> Error v
FloatPattern :: Ann -> Error v
tokenToPair :: Token a -> (Ann, a)
newtype Input
Input :: [Token Lexeme] -> Input
[inputStream] :: Input -> [Token Lexeme]
setPos :: SourcePos -> Pos -> SourcePos
class Annotated a
ann :: Annotated a => a -> Ann
label :: (Ord v, Show a) => String -> P v a -> P v a
traceRemainingTokens :: Ord v => String -> P v ()
mkAnn :: (Annotated a, Annotated b) => a -> b -> Ann
tok :: (Ann -> a -> b) -> Token a -> b
peekAny :: Ord v => P v (Token Lexeme)
lookAhead :: Ord v => P v a -> P v a
anyToken :: Ord v => P v (Token Lexeme)
failCommitted :: Ord v => Error v -> P v x
proxy :: Proxy Input
root :: Ord v => P v a -> P v a

rootFile :: Ord v => P v a -> P v a
run' :: Ord v => P v a -> String -> String -> ParsingEnv -> Either (Err v) a
run :: Ord v => P v a -> String -> ParsingEnv -> Either (Err v) a
queryToken :: Ord v => (Lexeme -> Maybe a) -> P v (Token a)
openBlock :: Ord v => P v (Token String)
openBlockWith :: Ord v => String -> P v (Token ())
matchToken :: Ord v => Lexeme -> P v (Token Lexeme)
importDotId :: Ord v => P v (Token Name)
semi :: Ord v => P v (Token ())
closeBlock :: Ord v => P v (Token ())
wordyPatternName :: Var v => P v (Token v)
prefixDefinitionName :: Var v => P v (Token v)
wordyDefinitionName :: Var v => P v (Token v)
wordyIdString :: Ord v => P v (Token String)
importWordyId :: Ord v => P v (Token Name)
importSymbolyId :: Ord v => P v (Token Name)
symbolyIdString :: Ord v => P v (Token String)
infixDefinitionName :: Var v => P v (Token v)
symbolyDefinitionName :: Var v => P v (Token v)
parenthesize :: Ord v => P v a -> P v a
hqPrefixId :: Ord v => P v (Token (HashQualified Name))
hqInfixId :: Ord v => P v (Token (HashQualified Name))
hqWordyId_ :: Ord v => P v (Token (HashQualified Name))
hqSymbolyId_ :: Ord v => P v (Token (HashQualified Name))
hqBacktickedId_ :: Ord v => P v (Token (HashQualified Name))
reserved :: Ord v => String -> P v (Token String)
blank :: Ord v => P v (Token String)
numeric :: Ord v => P v (Token String)
bytesToken :: Ord v => P v (Token Bytes)
sepBy :: Ord v => P v a -> P v b -> P v [b]
sepBy1 :: Ord v => P v a -> P v b -> P v [b]
sepEndBy :: Ord v => P v a -> P v b -> P v [b]
character :: Ord v => P v (Token Char)
string :: Ord v => P v (Token Text)
tupleOrParenthesized :: Ord v => P v a -> (Ann -> a) -> (a -> a -> a) -> P v a
seq :: Ord v => (Ann -> [a] -> a) -> P v a -> P v a
seq' :: Ord v => String -> (Ann -> [a] -> a) -> P v a -> P v a
chainr1 :: Ord v => P v a -> P v (a -> a -> a) -> P v a
chainl1 :: Ord v => P v a -> P v (a -> a -> a) -> P v a
failureIf :: Ord v => P v (P v b) -> P v a -> P v b
positionalVar :: (Annotated a, Var v) => a -> v -> v
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Parser.Error v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Parser.Error v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Parser.Error v)
instance GHC.Show.Show Unison.Parser.Input
instance GHC.Classes.Ord Unison.Parser.Input
instance GHC.Classes.Eq Unison.Parser.Input
instance Unison.Parser.Annotated Unison.Parser.Ann.Ann
instance Unison.Parser.Annotated (Unison.Lexer.Token a)
instance Unison.Parser.Annotated a => Unison.Parser.Annotated (Unison.ABT.Term f v a)
instance Unison.Parser.Annotated a => Unison.Parser.Annotated (Unison.Pattern.Pattern a)
instance Unison.Parser.Annotated a => Unison.Parser.Annotated [a]
instance (Unison.Parser.Annotated a, Unison.Parser.Annotated b) => Unison.Parser.Annotated (Unison.Term.MatchCase a b)
instance Text.Megaparsec.Stream.Stream Unison.Parser.Input
instance (GHC.Classes.Ord v, GHC.Show.Show v) => Text.Megaparsec.Error.ShowErrorComponent (Unison.Parser.Error v)
instance GHC.Base.Semigroup Unison.Parser.UniqueName
instance GHC.Base.Monoid Unison.Parser.UniqueName

module Unison.TypeParser
type TypeP v = P v (Type v Ann)
valueType :: Var v => TypeP v
computationType :: Var v => TypeP v
valueTypeLeaf :: Var v => TypeP v
typeAtom :: Var v => TypeP v
type1 :: Var v => TypeP v
type2a :: Var v => TypeP v
delayed :: Var v => TypeP v
type2 :: Var v => TypeP v
effect :: Var v => TypeP v
effectList :: Var v => TypeP v
sequenceTyp :: Var v => TypeP v
tupleOrParenthesizedType :: Var v => TypeP v -> TypeP v
arrow :: Var v => TypeP v -> TypeP v
forall :: Var v => TypeP v -> TypeP v

module Unison.TermParser
watch :: Show a => String -> a -> a
type TermP v = P v (Term v Ann)
term :: Var v => TermP v
term2 :: Var v => TermP v
term3 :: Var v => TermP v
keywordBlock :: Var v => TermP v
typeLink' :: Var v => P v (Token Reference)
termLink' :: Var v => P v (Token Referent)
link' :: Var v => P v (Either (Token Reference) (Token Referent))
link :: Var v => TermP v
blockTerm :: Var v => TermP v
match :: Var v => TermP v
matchCases :: Var v => P v [(Int, MatchCase Ann (Term v Ann))]
matchCase :: Var v => P v (Int, [MatchCase Ann (Term v Ann)])
parsePattern :: forall v. Var v => P v (Pattern Ann, [(Ann, v)])
lam :: Var v => TermP v -> TermP v
letBlock :: Var v => TermP v
handle :: Var v => TermP v
lamCase :: Var v => TermP v
ifthen :: Var v => TermP v
checkCasesArities :: (Ord v, Annotated a) => [(Int, a)] -> P v (Int, [a])
text :: Var v => TermP v
char :: Var v => TermP v
boolean :: Var v => TermP v
list :: Var v => TermP v -> TermP v
hashQualifiedPrefixTerm :: Var v => TermP v
hashQualifiedInfixTerm :: Var v => TermP v
quasikeyword :: Ord v => String -> P v (Token ())
resolveHashQualified :: Var v => Token (HashQualified Name) -> TermP v
termLeaf :: forall v. Var v => TermP v
doc2Block :: forall v. Var v => TermP v
docBlock :: Var v => TermP v
data UnbreakCase
LineEnds :: UnbreakCase
StartsIndented :: UnbreakCase
StartsUnindented :: UnbreakCase
docNormalize :: (Ord v, Show v) => Term v a -> Term v a
delayQuote :: Var v => TermP v
bang :: Var v => TermP v
var :: Var v => Token v -> Term v Ann
seqOp :: Ord v => P v SeqOp
term4 :: Var v => TermP v
infixAppOrBooleanOp :: Var v => TermP v
typedecl :: Var v => P v (Token v, Type v Ann)
verifyRelativeVarName :: Var v => P v (Token v) -> P v (Token v)
verifyRelativeName :: Ord v => P v (Token Name) -> P v (Token Name)
verifyRelativeName' :: Ord v => Token Name -> P v ()
destructuringBind :: forall v. Var v => P v (Ann, Term v Ann -> Term v Ann)
binding :: forall v. Var v => P v ((Ann, v), Term v Ann)
customFailure :: MonadParsec e s m => e -> m a
block :: forall v. Var v => String -> TermP v
importp :: Ord v => P v [(Name, Name)]
data BlockElement v
Binding :: ((Ann, v), Term v Ann) -> BlockElement v
DestructuringBind :: (Ann, Term v Ann -> Term v Ann) -> BlockElement v
Action :: Term v Ann -> BlockElement v
imports :: Var v => P v (NamesWithHistory, [(v, v)])
substImports :: Var v => NamesWithHistory -> [(v, v)] -> Term v Ann -> Term v Ann
block' :: Var v => IsTop -> String -> P v (Token ()) -> P v b -> TermP v
block'' :: forall v b. Var v => IsTop -> Bool -> String -> P v (Token ()) -> P v b -> TermP v
number :: Var v => TermP v
bytes :: Var v => TermP v
number' :: Ord v => (Token Int64 -> a) -> (Token Word64 -> a) -> (Token Double -> a) -> P v a
tupleOrParenthesizedTerm :: Var v => TermP v
instance GHC.Show.Show Unison.TermParser.UnbreakCase
instance GHC.Classes.Eq Unison.TermParser.UnbreakCase
instance GHC.Show.Show v => GHC.Show.Show (Unison.TermParser.BlockElement v)

module Unison.FileParser
resolutionFailures :: Ord v => [ResolutionFailure v Ann] -> P v x
file :: forall v. Var v => P v (UnisonFile v Ann)
data Stanza v term
WatchBinding :: WatchKind -> Ann -> ((Ann, v), term) -> Stanza v term
WatchExpression :: WatchKind -> Text -> Ann -> term -> Stanza v term
Binding :: ((Ann, v), term) -> Stanza v term
Bindings :: [((Ann, v), term)] -> Stanza v term
getVars :: Var v => Stanza v term -> [v]
stanza :: Var v => P v (Stanza v (Term v Ann))
watched :: Var v => P v (WatchKind, Text, Ann)
closed :: Var v => P v ()
type Accessors v = [(Token v, [(Token v, Type v Ann)])]
declarations :: Var v => P v (Map v (DataDeclaration v Ann), Map v (EffectDeclaration v Ann), Accessors v)
modifier :: Var v => P v (Maybe (Token Modifier))
declaration :: Var v => P v (Either (v, DataDeclaration v Ann, Accessors v) (v, EffectDeclaration v Ann))
dataDeclaration :: forall v. Var v => Maybe (Token Modifier) -> P v (v, DataDeclaration v Ann, Accessors v)
effectDeclaration :: Var v => Maybe (Token Modifier) -> P v (v, EffectDeclaration v Ann)
instance GHC.Base.Functor (Unison.FileParser.Stanza v)
instance Data.Traversable.Traversable (Unison.FileParser.Stanza v)
instance Data.Foldable.Foldable (Unison.FileParser.Stanza v)

module Unison.Codebase.Path.Parse
parsePath' :: String -> Either String Path'
parsePathImpl' :: String -> Either String (Path', String)
parseSplit' :: (String -> Either String NameSegment) -> String -> Either String Split'
definitionNameSegment :: String -> Either String NameSegment
parseHQSplit :: String -> Either String HQSplit
parseHQSplit' :: String -> Either String HQSplit'
parseShortHashOrHQSplit' :: String -> Either String (Either ShortHash HQSplit')
wordyNameSegment :: String -> Either String NameSegment

module Unison.Util.Star3
data Star3 fact d1 d2 d3
Star3 :: Set fact -> Relation fact d1 -> Relation fact d2 -> Relation fact d3 -> Star3 fact d1 d2 d3
[fact] :: Star3 fact d1 d2 d3 -> Set fact
[d1] :: Star3 fact d1 d2 d3 -> Relation fact d1
[d2] :: Star3 fact d1 d2 d3 -> Relation fact d2
[d3] :: Star3 fact d1 d2 d3 -> Relation fact d3
toList :: (Ord fact, Ord d1, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d1, d2, d3)]
difference :: (Ord fact, Ord d1, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
d23s :: (Ord fact, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d2, d3)]
d23s' :: (Ord fact, Ord d2, Ord d3) => Star3 fact d1 d2 d3 -> [(d2, d3)]
d12s :: (Ord fact, Ord d1, Ord d2) => Star3 fact d1 d2 d3 -> [(fact, d1, d2)]
d13s :: (Ord fact, Ord d1, Ord d3) => Star3 fact d1 d2 d3 -> [(fact, d1, d3)]
mapD1 :: (Ord fact, Ord d1, Ord d1a) => (d1 -> d1a) -> Star3 fact d1 d2 d3 -> Star3 fact d1a d2 d3
mapD2 :: (Ord fact, Ord d2, Ord d2a) => (d2 -> d2a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2a d3
mapD3 :: (Ord fact, Ord d3, Ord d3a) => (d3 -> d3a) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3a
fromList :: (Ord fact, Ord d1, Ord d2, Ord d3) => [(fact, d1, d2, d3)] -> Star3 fact d1 d2 d3
selectFact :: (Ord fact, Ord d1, Ord d2, Ord d3) => Set fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
select1D3 :: (Ord fact, Ord d1, Ord d2, Ord d3) => d3 -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
selectD3 :: (Ord fact, Ord d1, Ord d2, Ord d3) => Set d3 -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deletePrimaryD1 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d1) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
lookupD1 :: (Ord fact, Ord d1) => d1 -> Star3 fact d1 d2 d3 -> Set fact
insertD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
memberD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star3 fact d1 d2 d3 -> Bool
memberD2 :: (Ord fact, Ord d2) => (fact, d2) -> Star3 fact d1 d2 d3 -> Bool
memberD3 :: (Ord fact, Ord d3) => (fact, d3) -> Star3 fact d1 d2 d3 -> Bool
insert :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d1, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
insertD23 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d2, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deleteD3 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d3) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deleteD2 :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact, d2) -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
deleteFact :: (Ord fact, Ord d1, Ord d2, Ord d3) => Set fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
replaceFacts :: (Ord fact, Ord d1, Ord d2, Ord d3) => (fact -> fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3) -> Map fact fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
replaceFact :: (Ord fact, Ord d1, Ord d2, Ord d3) => fact -> fact -> Star3 fact d1 d2 d3 -> Star3 fact d1 d2 d3
instance (GHC.Show.Show fact, GHC.Show.Show d1, GHC.Show.Show d2, GHC.Show.Show d3) => GHC.Show.Show (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2, GHC.Classes.Ord d3) => GHC.Classes.Ord (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Eq fact, GHC.Classes.Eq d1, GHC.Classes.Eq d2, GHC.Classes.Eq d3) => GHC.Classes.Eq (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2, GHC.Classes.Ord d3) => GHC.Base.Semigroup (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2, GHC.Classes.Ord d3) => GHC.Base.Monoid (Unison.Util.Star3.Star3 fact d1 d2 d3)
instance (Unison.Hashable.Hashable fact, Unison.Hashable.Hashable d1, Unison.Hashable.Hashable d2, Unison.Hashable.Hashable d3) => Unison.Hashable.Hashable (Unison.Util.Star3.Star3 fact d1 d2 d3)

module Unison.Codebase.Metadata
type Type = Reference
type Value = Reference
type Metadata = Map Type (Set Value)
type Star a n = Star3 a n Type (Type, Value)
type R4 a n = Relation4 a n Type Value
starToR4 :: (Ord r, Ord n) => Star r n -> Relation4 r n Type Value
hasMetadata :: Ord a => a -> Type -> Value -> Star a n -> Bool
hasMetadataWithType' :: Ord a => a -> Type -> R4 a n -> Bool
hasMetadataWithType :: Ord a => a -> Type -> Star a n -> Bool
inserts :: (Ord a, Ord n) => [(a, Type, Value)] -> Star a n -> Star a n
insertWithMetadata :: (Ord a, Ord n) => (a, Metadata) -> Star a n -> Star a n
insert :: (Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n
delete :: (Ord a, Ord n) => (a, Type, Value) -> Star a n -> Star a n
merge :: Metadata -> Metadata -> Metadata
append :: Metadata -> Metadata -> Metadata
empty :: Metadata
singleton :: Type -> Value -> Metadata
toRelation :: Star3 a n x y -> Relation a n

module Unison.Codebase.Branch

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[_history] :: Branch m -> UnwrappedBranch m
data BranchDiff
BranchDiff :: Star Referent NameSegment -> Star Referent NameSegment -> Star TypeReference NameSegment -> Star TypeReference NameSegment -> Map NameSegment PatchDiff -> BranchDiff
[addedTerms] :: BranchDiff -> Star Referent NameSegment
[removedTerms] :: BranchDiff -> Star Referent NameSegment
[addedTypes] :: BranchDiff -> Star TypeReference NameSegment
[removedTypes] :: BranchDiff -> Star TypeReference NameSegment
[changedPatches] :: BranchDiff -> Map NameSegment PatchDiff
type UnwrappedBranch m = Causal m Raw (Branch0 m)

-- | A node in the Unison namespace hierarchy.
--   
--   <a>_terms</a> and <a>_types</a> are the declarations at this level.
--   <a>_children</a> are the nodes one level below us. <a>_edits</a> are
--   the <a>Patch</a>s stored at this node in the code.
--   
--   The <tt>deep*</tt> fields are derived from the four above.
data Branch0 m
Branch0 :: Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (EditHash, m Patch) -> Relation Referent Name -> Relation TypeReference Name -> R4 Referent Name -> R4 TypeReference Name -> Set Path -> Map Name EditHash -> Branch0 m
[_terms] :: Branch0 m -> Star Referent NameSegment
[_types] :: Branch0 m -> Star TypeReference NameSegment

-- | Note the <a>Branch</a> here, not <a>Branch0</a>. Every level in the
--   tree has a history.
[_children] :: Branch0 m -> Map NameSegment (Branch m)
[_edits] :: Branch0 m -> Map NameSegment (EditHash, m Patch)
[deepTerms] :: Branch0 m -> Relation Referent Name
[deepTypes] :: Branch0 m -> Relation TypeReference Name
[deepTermMetadata] :: Branch0 m -> R4 Referent Name
[deepTypeMetadata] :: Branch0 m -> R4 TypeReference Name
[deepPaths] :: Branch0 m -> Set Path
[deepEdits] :: Branch0 m -> Map Name EditHash
data Raw
Raw :: Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment Hash -> Map NameSegment EditHash -> Raw
[_termsR] :: Raw -> Star Referent NameSegment
[_typesR] :: Raw -> Star TypeReference NameSegment
[_childrenR] :: Raw -> Map NameSegment Hash
[_editsR] :: Raw -> Map NameSegment EditHash
type Star r n = Star r n
type Hash = RawHash Raw
type EditHash = Hash
pattern Hash :: Hash -> RawHash a
branch0 :: forall m. Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (EditHash, m Patch) -> Branch0 m
one :: Branch0 m -> Branch m
cons :: Applicative m => Branch0 m -> Branch m -> Branch m
uncons :: Applicative m => Branch m -> m (Maybe (Branch0 m, Branch m))
empty :: Branch m
empty0 :: Branch0 m

-- | Discards the history of a Branch and its children, recursively
discardHistory :: Applicative m => Branch m -> Branch m

-- | Discards the history of a Branch0's children, recursively
discardHistory0 :: Applicative m => Branch0 m -> Branch0 m
toCausalRaw :: Branch m -> Raw Raw Raw
transform :: Functor m => (forall a. m a -> n a) -> Branch m -> Branch n

-- | Checks whether a branch is empty AND has no history.
isEmpty :: Branch m -> Bool

-- | Checks whether a Branch0 is empty, which means that the branch
--   contains no terms or types, and that the heads of all children are
--   empty by the same definition. This is not as easy as checking whether
--   the branch is equal to the <a>empty0</a> branch because child branches
--   may be empty, but still have history.
isEmpty0 :: Branch0 m -> Bool
isOne :: Branch m -> Bool
before :: Monad m => Branch m -> Branch m -> m Bool
lca :: Monad m => Branch m -> Branch m -> m (Maybe (Branch m))
diff0 :: Monad m => Branch0 m -> Branch0 m -> m BranchDiff
history :: Iso' (Branch m) (UnwrappedBranch m)
head :: Branch m -> Branch0 m
headHash :: Branch m -> Hash
children :: Lens' (Branch0 m) (Map NameSegment (Branch m))
nonEmptyChildren :: Branch0 m -> Map NameSegment (Branch m)

-- | a version of <a>deepEdits</a> that returns the `m Patch` as well.
deepEdits' :: Branch0 m -> Map Name (EditHash, m Patch)

-- | what does this do? â€”AI
toList0 :: Branch0 m -> [(Path, Branch0 m)]

-- | Run a series of updates at specific locations, aggregating all changes
--   into a single causal step. History is managed according to
--   <a>UpdateStrategy</a>.
stepManyAt :: forall m f. (Monad m, Foldable f) => UpdateStrategy -> f (Path, Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations. History is managed
--   according to the <a>UpdateStrategy</a>
stepManyAtM :: (Monad m, Monad n, Foldable f) => UpdateStrategy -> f (Path, Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m)
stepEverywhere :: Applicative m => (Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Perform updates over many locations within a branch by batching up
--   operations on sub-branches as much as possible without affecting
--   semantics. This operation does not create any causal conses, the
--   operations are performed directly on the current head of the provided
--   branch and child branches. It's the caller's responsibility to apply
--   updates in history however they choose.
batchUpdates :: forall f m. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Batch many updates. This allows us to apply the updates while
--   minimizing redundant traversals. Semantics of operations are preserved
--   by ensuring that all updates will always see changes by updates before
--   them in the list.
--   
--   This method does not <a>step</a> any branches on its own, all causal
--   changes must be performed in the updates themselves, or this batch
--   update must be provided to 'stepManyAt(M)'.
batchUpdatesM :: forall m n f. (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch0 m -> n (Branch0 m)
data UpdateStrategy

-- | Compress all changes into a single causal cons. The resulting branch
--   will have at most one new causal cons at each branch.
--   
--   Note that this does NOT allow updates to add histories at children.
--   E.g. if the root.editme branch has history: A -&gt; B -&gt; C and you
--   use <tt>makeSetBranch</tt> to update it to a new branch with history X
--   -&gt; Y -&gt; Z, CompressHistory will result in a history for
--   root.editme of: A -&gt; B -&gt; C -&gt; Z. A <tt>snapshot</tt> of the
--   most recent state of the updated branch is appended to the existing
--   history, if the new state is equal to the existing state, no new
--   history nodes are appended.
CompressHistory :: UpdateStrategy

-- | Preserves any history changes made within the update.
--   
--   Note that this allows you to clobber the history child branches if you
--   want. E.g. if the root.editme branch has history: A -&gt; B -&gt; C
--   and you use <tt>makeSetBranch</tt> to update it to a new branch with
--   history X -&gt; Y -&gt; Z, AllowRewritingHistory will result in a
--   history for root.editme of: X -&gt; Y -&gt; Z. The history of the
--   updated branch is replaced entirely.
AllowRewritingHistory :: UpdateStrategy
addTermName :: Referent -> NameSegment -> Metadata -> Branch0 m -> Branch0 m
addTypeName :: TypeReference -> NameSegment -> Metadata -> Branch0 m -> Branch0 m
deleteTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m
deleteTypeName :: TypeReference -> NameSegment -> Branch0 m -> Branch0 m
setChildBranch :: NameSegment -> Branch m -> Branch0 m -> Branch0 m
replacePatch :: Applicative m => NameSegment -> Patch -> Branch0 m -> Branch0 m
deletePatch :: NameSegment -> Branch0 m -> Branch0 m
getMaybePatch :: Applicative m => NameSegment -> Branch0 m -> m (Maybe Patch)
getPatch :: Applicative m => NameSegment -> Branch0 m -> m Patch
modifyPatches :: Monad m => NameSegment -> (Patch -> Patch) -> Branch0 m -> m (Branch0 m)
getAt :: Path -> Branch m -> Maybe (Branch m)
getAt' :: Path -> Branch m -> Branch m
getAt0 :: Path -> Branch0 m -> Branch0 m
modifyAt :: Applicative m => Path -> (Branch m -> Branch m) -> Branch m -> Branch m
modifyAtM :: forall n m. Functor n => Applicative m => Path -> (Branch m -> n (Branch m)) -> Branch m -> n (Branch m)

-- | Traverse the head branch of all direct children. The index of the
--   traversal is the name of that child branch according to the parent.
children0 :: IndexedTraversal' NameSegment (Branch0 m) (Branch0 m)
terms :: Lens' (Branch0 m) (Star Referent NameSegment)
types :: Lens' (Branch0 m) (Star TypeReference NameSegment)
edits :: Lens' (Branch0 m) (Map NameSegment (EditHash, m Patch))
deepReferents :: Branch0 m -> Set Referent
deepTypeReferences :: Branch0 m -> Set TypeReference
cachedRead :: forall m. MonadIO m => Cache m -> Deserialize m Raw Raw -> (EditHash -> m Patch) -> Hash -> m (Branch m)
type Cache m = Cache (RawHash Raw) (UnwrappedBranch m)
sync :: Monad m => (Hash -> m Bool) -> Serialize m Raw Raw -> (EditHash -> m Patch -> m ()) -> Branch m -> m ()

-- | <tt>head <a>consBranchSnapshot</a> base</tt> Cons's the current state
--   of <tt>head</tt> onto <tt>base</tt> as-is. Consider whether you really
--   want this behaviour or the behaviour of <a>squashMerge</a> That is, it
--   does not perform any common ancestor detection, or change
--   reconciliation, it sets the current state of the base branch to the
--   new state as a new causal step (or returns the existing base if there
--   are no)
consBranchSnapshot :: forall m. Monad m => Branch m -> Branch m -> Branch m
instance GHC.Show.Show Unison.Codebase.Branch.BranchDiff
instance GHC.Classes.Ord Unison.Codebase.Branch.BranchDiff
instance GHC.Classes.Eq Unison.Codebase.Branch.BranchDiff
instance GHC.Classes.Ord (Unison.Codebase.Branch.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Branch m)
instance GHC.Classes.Eq Unison.Codebase.Branch.ActionLocation
instance Control.Lens.Empty.AsEmpty (Unison.Codebase.Branch.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Branch0 m)
instance Unison.Hashable.Hashable (Unison.Codebase.Branch.Branch0 m)
instance GHC.Base.Semigroup Unison.Codebase.Branch.BranchDiff
instance GHC.Base.Monoid Unison.Codebase.Branch.BranchDiff

module Unison.Codebase.Type

-- | Abstract interface to a user's codebase.
data Codebase m v a
Codebase :: (Id -> m (Maybe (Term v a))) -> (Id -> m (Maybe (Type v a))) -> (Id -> m (Maybe (Decl v a))) -> (Id -> Term v a -> Type v a -> m ()) -> (Id -> Decl v a -> m ()) -> m (Either GetRootBranchError (Branch m)) -> m Bool -> (Branch m -> m ()) -> m (IO (), IO (Set Hash)) -> (Hash -> m (Maybe (Branch m))) -> (Branch m -> m ()) -> (Hash -> m Bool) -> (EditHash -> m (Maybe Patch)) -> (EditHash -> Patch -> m ()) -> (EditHash -> m Bool) -> (Reference -> m (Set Id)) -> (CodebasePath -> SyncMode -> Branch m -> m ()) -> (CodebasePath -> SyncMode -> Branch m -> m ()) -> (forall r. ReadRemoteNamespace -> ((Branch m, CodebasePath) -> m r) -> m (Either GitError r)) -> (Branch m -> WriteRepo -> PushGitBranchOpts -> m (Either GitError ())) -> (WatchKind -> m [Id]) -> (WatchKind -> Id -> m (Maybe (Term v a))) -> (WatchKind -> Id -> Term v a -> m ()) -> m () -> m [Entry Hash] -> (Text -> Branch m -> Branch m -> m ()) -> (Reference -> m (Set Id)) -> (Reference -> m (Set Id)) -> m Int -> (ShortHash -> m (Set Id)) -> (ShortHash -> m (Set Id)) -> (ShortHash -> m (Set Id)) -> m Int -> (ShortBranchHash -> m (Set Hash)) -> Maybe (Hash -> Hash -> m (Maybe Hash)) -> Maybe (Hash -> Hash -> m Bool) -> Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>putTerm</a>, then <a>getTerm</a>,
--   and receive <tt>Nothing</tt>, per the semantics of <a>putTerm</a>.
[getTerm] :: Codebase m v a -> Id -> m (Maybe (Term v a))

-- | Get the type of a user-defined term.
--   
--   Note that it is possible to call <a>putTerm</a>, then
--   <a>getTypeOfTermImpl</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>putTerm</a>.
[getTypeOfTermImpl] :: Codebase m v a -> Id -> m (Maybe (Type v a))

-- | Get a type declaration.
--   
--   Note that it is possible to call <a>putTypeDeclaration</a>, then
--   <a>getTypeDeclaration</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>putTypeDeclaration</a>.
[getTypeDeclaration] :: Codebase m v a -> Id -> m (Maybe (Decl v a))

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
[putTerm] :: Codebase m v a -> Id -> Term v a -> Type v a -> m ()

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
[putTypeDeclaration] :: Codebase m v a -> Id -> Decl v a -> m ()

-- | Get the root branch.
[getRootBranch] :: Codebase m v a -> m (Either GetRootBranchError (Branch m))

-- | Get whether the root branch exists.
[getRootBranchExists] :: Codebase m v a -> m Bool

-- | Like <a>putBranch</a>, but also adjusts the root branch pointer
--   afterwards.
[putRootBranch] :: Codebase m v a -> Branch m -> m ()
[rootBranchUpdates] :: Codebase m v a -> m (IO (), IO (Set Hash))
[getBranchForHashImpl] :: Codebase m v a -> Hash -> m (Maybe (Branch m))

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
[putBranch] :: Codebase m v a -> Branch m -> m ()

-- | Check whether the given branch exists in the codebase.
[branchExists] :: Codebase m v a -> Hash -> m Bool

-- | Get a patch from the codebase.
[getPatch] :: Codebase m v a -> EditHash -> m (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
[putPatch] :: Codebase m v a -> EditHash -> Patch -> m ()

-- | Check whether the given patch exists in the codebase.
[patchExists] :: Codebase m v a -> EditHash -> m Bool

-- | Get the set of user-defined terms and type declarations that depend on
--   the given term, type declaration, or builtin type.
[dependentsImpl] :: Codebase m v a -> Reference -> m (Set Id)

-- | Copy a branch and all of its dependencies from the given codebase into
--   this one.
[syncFromDirectory] :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from this codebase into the
--   given codebase.
[syncToDirectory] :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()
[viewRemoteBranch'] :: Codebase m v a -> forall r. ReadRemoteNamespace -> ((Branch m, CodebasePath) -> m r) -> m (Either GitError r)

-- | Push the given branch to the given repo, and optionally set it as the
--   root branch.
[pushGitBranch] :: Codebase m v a -> Branch m -> WriteRepo -> PushGitBranchOpts -> m (Either GitError ())

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
[watches] :: Codebase m v a -> WatchKind -> m [Id]

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
[getWatch] :: Codebase m v a -> WatchKind -> Id -> m (Maybe (Term v a))

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     â§©
--     7
--   </pre>
[putWatch] :: Codebase m v a -> WatchKind -> Id -> Term v a -> m ()

-- | Delete all watches that were put by <a>putWatch</a>.
[clearWatches] :: Codebase m v a -> m ()

-- | Get the entire reflog.
[getReflog] :: Codebase m v a -> m [Entry Hash]

-- | <tt>appendReflog reason before after</tt> appends a reflog entry.
--   
--   FIXME: this could have type
--   
--   <pre>
--   appendReflog :: Reflog.Entry (Branch m) -&gt; m ()
--   </pre>
[appendReflog] :: Codebase m v a -> Text -> Branch m -> Branch m -> m ()

-- | Get the set of user-defined terms-or-constructors that have the given
--   type.
[termsOfTypeImpl] :: Codebase m v a -> Reference -> m (Set Id)

-- | Get the set of user-defined terms-or-constructors mention the given
--   type anywhere in their signature.
[termsMentioningTypeImpl] :: Codebase m v a -> Reference -> m (Set Id)

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
[hashLength] :: Codebase m v a -> m Int

-- | Get the set of user-defined terms whose hash matches the given prefix.
[termReferencesByPrefix] :: Codebase m v a -> ShortHash -> m (Set Id)

-- | Get the set of type declarations whose hash matches the given prefix.
[typeReferencesByPrefix] :: Codebase m v a -> ShortHash -> m (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
[termReferentsByPrefix] :: Codebase m v a -> ShortHash -> m (Set Id)

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
[branchHashLength] :: Codebase m v a -> m Int

-- | Get the set of branches whose hash matches the given prefix.
[branchHashesByPrefix] :: Codebase m v a -> ShortBranchHash -> m (Set Hash)
[lcaImpl] :: Codebase m v a -> Maybe (Hash -> Hash -> m (Maybe Hash))
[beforeImpl] :: Codebase m v a -> Maybe (Hash -> Hash -> m Bool)

-- | A directory that contains a codebase.
type CodebasePath = FilePath
data PushGitBranchOpts
PushGitBranchOpts :: Bool -> SyncMode -> PushGitBranchOpts

-- | Set the branch as root?
[setRoot] :: PushGitBranchOpts -> Bool
[syncMode] :: PushGitBranchOpts -> SyncMode
data GitError
GitProtocolError :: GitProtocolError -> GitError
GitCodebaseError :: GitCodebaseError Hash -> GitError
GitSqliteCodebaseError :: GitSqliteCodebaseError -> GitError
data GetRootBranchError
NoRootBranch :: GetRootBranchError
CouldntParseRootBranch :: String -> GetRootBranchError
CouldntLoadRootBranch :: Hash -> GetRootBranchError
type SyncToDir m = CodebasePath -> SyncMode -> Branch m -> m ()
instance GHC.Show.Show Unison.Codebase.Type.GetRootBranchError
instance GHC.Show.Show Unison.Codebase.Type.GitError
instance GHC.Exception.Type.Exception Unison.Codebase.Type.GitError

module Unison.Codebase.SqliteCodebase.Conversions
sbh1to2 :: ShortBranchHash -> ShortBranchHash
decltype2to1 :: DeclType -> ConstructorType
decltype1to2 :: ConstructorType -> DeclType
watchKind1to2 :: WatchKind -> WatchKind
watchKind2to1 :: WatchKind -> WatchKind
term1to2 :: Hash -> Term Symbol Ann -> Term Symbol
term2to1 :: forall m. Monad m => Hash -> (Hash -> m Size) -> (Reference -> m ConstructorType) -> Term Symbol -> m (Term Symbol Ann)
decl2to1 :: Monad m => Hash -> (Hash -> m Size) -> Decl Symbol -> m (Decl Symbol Ann)
decl1to2 :: Hash -> Decl Symbol a -> Decl Symbol
symbol2to1 :: Symbol -> Symbol
symbol1to2 :: Symbol -> Symbol
shortHashSuffix1to2 :: Text -> Pos
abt2to1 :: Functor f => Term f v a -> Term f v a
abt1to2 :: Functor f => Term f v a -> Term f v a
rreference2to1 :: Applicative m => Hash -> (Hash -> m Size) -> Reference' Text (Maybe Hash) -> m Reference
rreference1to2 :: Hash -> Reference -> Reference' Text (Maybe Hash)
rreferenceid2to1 :: Functor m => Hash -> (Hash -> m Size) -> Id' (Maybe Hash) -> m Id
rreferenceid1to2 :: Hash -> Id -> Id' (Maybe Hash)
hash1to2 :: Hash -> Hash
branchHash1to2 :: Hash -> CausalHash
branchHash2to1 :: CausalHash -> Hash
patchHash1to2 :: EditHash -> PatchHash
reference2to1 :: Applicative m => (Hash -> m Size) -> Reference -> m Reference
reference1to2 :: Reference -> Reference
referenceid1to2 :: Id -> Id
referenceid2to1 :: Functor m => (Hash -> m Size) -> Id -> m Id
rreferent2to1 :: Applicative m => Hash -> (Hash -> m Size) -> (Reference -> m ConstructorType) -> ReferentH -> m Referent
rreferent1to2 :: Hash -> Referent -> ReferentH
referent2to1 :: Applicative m => (Hash -> m Size) -> (Reference -> m ConstructorType) -> Referent -> m Referent
referent1to2 :: Referent -> Referent
referentid2to1 :: Applicative m => (Hash -> m Size) -> (Reference -> m ConstructorType) -> Id -> m Id
hash2to1 :: Hash -> Hash
causalHash2to1 :: CausalHash -> RawHash Raw
causalHash1to2 :: RawHash Raw -> CausalHash
ttype2to1 :: Monad m => (Hash -> m Size) -> Type Symbol -> m (Type Symbol Ann)
dtype2to1 :: Monad m => Hash -> (Hash -> m Size) -> Type Symbol -> m (Type Symbol Ann)
type2to1' :: Monad m => (r -> m Reference) -> TypeR r Symbol -> m (Type Symbol Ann)
dtype1to2 :: Hash -> Type Symbol a -> TypeD Symbol
ttype1to2 :: Type Symbol a -> TypeT Symbol
type1to2' :: (Reference -> r) -> Type Symbol a -> TypeR r Symbol

-- | forces loading v1 branches even if they may not exist
causalbranch2to1 :: Monad m => (String -> Hash -> m Size) -> (Reference -> m ConstructorType) -> Causal m -> m (Branch m)
causalbranch2to1' :: Monad m => (String -> Hash -> m Size) -> (Reference -> m ConstructorType) -> Causal m -> m (UnwrappedBranch m)
causalbranch1to2 :: forall m. Monad m => Branch m -> Causal m
patch2to1 :: forall m. Monad m => (String -> Hash -> m Size) -> Patch -> m Patch
patch1to2 :: Patch -> Patch
edithash2to1 :: PatchHash -> EditHash
edithash1to2 :: EditHash -> PatchHash
namesegment2to1 :: NameSegment -> NameSegment
namesegment1to2 :: NameSegment -> NameSegment
branch2to1 :: Monad m => (String -> Hash -> m Size) -> (Reference -> m ConstructorType) -> Branch m -> m (Branch0 m)

module Unison.Codebase.SqliteCodebase.Branch.Dependencies
type Branches m = [(Hash, m (Branch m))]
data Dependencies
Dependencies :: Set EditHash -> Set Hash -> Set Hash -> Dependencies
[patches] :: Dependencies -> Set EditHash
[terms] :: Dependencies -> Set Hash
[decls] :: Dependencies -> Set Hash
data Dependencies'
Dependencies' :: [EditHash] -> [Hash] -> [Hash] -> Dependencies'
[patches'] :: Dependencies' -> [EditHash]
[terms'] :: Dependencies' -> [Hash]
[decls'] :: Dependencies' -> [Hash]
to' :: Dependencies -> Dependencies'
fromBranch :: Applicative m => Branch m -> (Branches m, Dependencies)
fromBranch0 :: Applicative m => Branch0 m -> (Branches m, Dependencies)
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'

module Unison.Codebase.BranchUtil

-- | Creates a branch containing all of the given names, with a single
--   history node.
fromNames :: Monad m => Names -> Branch m
getBranch :: Split -> Branch0 m -> Maybe (Branch m)
getTerm :: HQSplit -> Branch0 m -> Set Referent
getType :: HQSplit -> Branch0 m -> Set Reference
getTermMetadataAt :: (Path, a) -> Referent -> Branch0 m -> Metadata
getTypeMetadataAt :: (Path, a) -> Reference -> Branch0 m -> Metadata
getTermMetadataHQNamed :: (Path, HQSegment) -> Branch0 m -> R4 Referent NameSegment
getTypeMetadataHQNamed :: (Path, HQSegment) -> Branch0 m -> R4 Reference NameSegment
makeSetBranch :: Split -> Branch m -> (Path, Branch0 m -> Branch0 m)

-- | "delete"s a branch by cons'ing an empty Branch0 onto the history at
--   that location. See also <a>makeObliterateBranch</a>.
makeDeleteBranch :: Applicative m => Split -> (Path, Branch0 m -> Branch0 m)

-- | Erase a branch and its history See also <a>makeDeleteBranch</a>. Note
--   that this requires a AllowRewritingHistory update strategy to behave
--   correctly.
makeObliterateBranch :: Split -> (Path, Branch0 m -> Branch0 m)
makeAddTypeName :: Split -> Reference -> Metadata -> (Path, Branch0 m -> Branch0 m)
makeDeleteTypeName :: Split -> Reference -> (Path, Branch0 m -> Branch0 m)
makeAddTermName :: Split -> Referent -> Metadata -> (Path, Branch0 m -> Branch0 m)
makeDeleteTermName :: Split -> Referent -> (Path, Branch0 m -> Branch0 m)
makeDeletePatch :: Split -> (Path, Branch0 m -> Branch0 m)
makeReplacePatch :: Applicative m => Split -> Patch -> (Path, Branch0 m -> Branch0 m)

module Unison.Codebase.Branch.Names
findHistoricalHQs :: Monad m => Set (HashQualified Name) -> Branch m -> m (Set (HashQualified Name), Names)
findHistoricalRefs :: Monad m => Set LabeledDependency -> Branch m -> m (Set LabeledDependency, Names)
findHistoricalRefs' :: Monad m => Set Reference -> Branch m -> m (Set Reference, Names)
namesDiff :: Branch m -> Branch m -> Diff
toNames :: Branch0 m -> Names

module Unison.Codebase.Branch.Merge
data MergeMode
RegularMerge :: MergeMode
SquashMerge :: MergeMode
merge'' :: forall m. Monad m => (Branch m -> Branch m -> m (Maybe (Branch m))) -> MergeMode -> Branch m -> Branch m -> m (Branch m)
instance GHC.Show.Show Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Ord Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Eq Unison.Codebase.Branch.Merge.MergeMode

module Unison.Codebase

-- | Abstract interface to a user's codebase.
data Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>putTerm</a>, then <a>getTerm</a>,
--   and receive <tt>Nothing</tt>, per the semantics of <a>putTerm</a>.
getTerm :: Codebase m v a -> Id -> m (Maybe (Term v a))

-- | Like <a>getTerm</a>, for when the term is known to exist in the
--   codebase.
unsafeGetTerm :: (HasCallStack, Monad m) => Codebase m v a -> Id -> m (Term v a)

-- | Like <a>unsafeGetTerm</a>, but returns the type of the term, too.
unsafeGetTermWithType :: (HasCallStack, Monad m) => Codebase m v a -> Id -> m (Term v a, Type v a)

-- | Get the type of a term.
--   
--   Note that it is possible to call <a>putTerm</a>, then
--   <a>getTypeOfTerm</a>, and receive <tt>Nothing</tt>, per the semantics
--   of <a>putTerm</a>.
getTypeOfTerm :: (Applicative m, BuiltinAnnotation a) => Codebase m Symbol a -> Reference -> m (Maybe (Type Symbol a))

-- | Like <a>getTypeOfTerm</a>, but for when the term is known to exist in
--   the codebase.
unsafeGetTypeOfTermById :: (HasCallStack, Monad m) => Codebase m v a -> Id -> m (Type v a)

-- | Check whether a reference is a term.
isTerm :: (Applicative m, BuiltinAnnotation a) => Codebase m Symbol a -> Reference -> m Bool

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
putTerm :: Codebase m v a -> Id -> Term v a -> Type v a -> m ()

-- | Get the type of a referent.
getTypeOfReferent :: (BuiltinAnnotation a, Monad m) => Codebase m Symbol a -> Referent -> m (Maybe (Type Symbol a))

-- | Get the set of terms-or-constructors that have the given type.
termsOfType :: (Var v, Functor m) => Codebase m v a -> Type v a -> m (Set Referent)

-- | Get the set of terms-or-constructors mention the given type anywhere
--   in their signature.
termsMentioningType :: (Var v, Functor m) => Codebase m v a -> Type v a -> m (Set Referent)

-- | Get the set of user-defined terms whose hash matches the given prefix.
termReferencesByPrefix :: Codebase m v a -> ShortHash -> m (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
termReferentsByPrefix :: Codebase m v a -> ShortHash -> m (Set Id)

-- | Get a type declaration.
--   
--   Note that it is possible to call <a>putTypeDeclaration</a>, then
--   <a>getTypeDeclaration</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>putTypeDeclaration</a>.
getTypeDeclaration :: Codebase m v a -> Id -> m (Maybe (Decl v a))

-- | Like <a>getTypeDeclaration</a>, for when the type declaration is known
--   to exist in the codebase.
unsafeGetTypeDeclaration :: (HasCallStack, Monad m) => Codebase m v a -> Id -> m (Decl v a)

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
putTypeDeclaration :: Codebase m v a -> Id -> Decl v a -> m ()

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: Codebase m v a -> ShortHash -> m (Set Id)
isType :: Applicative m => Codebase m v a -> Reference -> m Bool

-- | Check whether the given branch exists in the codebase.
branchExists :: Codebase m v a -> Hash -> m Bool

-- | Get a branch from the codebase.
getBranchForHash :: Monad m => Codebase m v a -> Hash -> m (Maybe (Branch m))

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
putBranch :: Codebase m v a -> Branch m -> m ()

-- | Get the set of branches whose hash matches the given prefix.
branchHashesByPrefix :: Codebase m v a -> ShortBranchHash -> m (Set Hash)

-- | Get the lowest common ancestor of two branches, i.e. the most recent
--   branch that is an ancestor of both branches.
lca :: Monad m => Codebase m v a -> Branch m -> Branch m -> m (Maybe (Branch m))
beforeImpl :: Codebase m v a -> Maybe (Hash -> Hash -> m Bool)

-- | Get the root branch.
getRootBranch :: Codebase m v a -> m (Either GetRootBranchError (Branch m))

-- | Get whether the root branch exists.
getRootBranchExists :: Codebase m v a -> m Bool
data GetRootBranchError
NoRootBranch :: GetRootBranchError
CouldntParseRootBranch :: String -> GetRootBranchError
CouldntLoadRootBranch :: Hash -> GetRootBranchError

-- | Like <a>putBranch</a>, but also adjusts the root branch pointer
--   afterwards.
putRootBranch :: Codebase m v a -> Branch m -> m ()
rootBranchUpdates :: Codebase m v a -> m (IO (), IO (Set Hash))

-- | Check whether the given patch exists in the codebase.
patchExists :: Codebase m v a -> EditHash -> m Bool

-- | Get a patch from the codebase.
getPatch :: Codebase m v a -> EditHash -> m (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: Codebase m v a -> EditHash -> Patch -> m ()

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
getWatch :: Codebase m v a -> WatchKind -> Id -> m (Maybe (Term v a))

-- | Like <a>getWatch</a>, but first looks up the given reference as a
--   regular watch, then as a test watch.
--   
--   <pre>
--   lookupWatchCache codebase ref =
--     runMaybeT do
--       MaybeT (getWatch codebase RegularWatch ref)
--         <a>|</a> MaybeT (getWatch codebase TestWatch ref))
--   </pre>
lookupWatchCache :: Monad m => Codebase m v a -> Id -> m (Maybe (Term v a))

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: Codebase m v a -> WatchKind -> m [Id]

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     â§©
--     7
--   </pre>
putWatch :: Codebase m v a -> WatchKind -> Id -> Term v a -> m ()

-- | Delete all watches that were put by <a>putWatch</a>.
clearWatches :: Codebase m v a -> m ()

-- | Get the entire reflog.
getReflog :: Codebase m v a -> m [Entry Hash]

-- | <tt>appendReflog reason before after</tt> appends a reflog entry.
--   
--   FIXME: this could have type
--   
--   <pre>
--   appendReflog :: Reflog.Entry (Branch m) -&gt; m ()
--   </pre>
appendReflog :: Codebase m v a -> Text -> Branch m -> Branch m -> m ()

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Codebase m v a -> m Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Codebase m v a -> m Int

-- | Get the set of terms, type declarations, and builtin types that depend
--   on the given term, type declaration, or builtin type.
dependents :: Functor m => Codebase m v a -> Reference -> m (Set Reference)

-- | Copy a branch and all of its dependencies from the given codebase into
--   this one.
syncFromDirectory :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()

-- | Copy a branch and all of its dependencies from this codebase into the
--   given codebase.
syncToDirectory :: Codebase m v a -> CodebasePath -> SyncMode -> Branch m -> m ()

-- | Pull a git branch and view it from the cache, without syncing into the
--   local codebase.
viewRemoteBranch :: MonadIO m => Codebase m v a -> ReadRemoteNamespace -> (Branch m -> m r) -> m (Either GitError r)

-- | Sync elements as needed from a remote codebase into the local one. If
--   <tt>sbh</tt> is supplied, we try to load the specified branch hash;
--   otherwise we try to load the root branch.
importRemoteBranch :: forall m v a. MonadUnliftIO m => Codebase m v a -> ReadRemoteNamespace -> SyncMode -> Preprocessing m -> m (Either GitError (Branch m))

-- | An optional preprocessing step to run on branches before they're
--   imported into the local codebase.
data Preprocessing m
Unmodified :: Preprocessing m
Preprocessed :: (Branch m -> m (Branch m)) -> Preprocessing m

-- | Push the given branch to the given repo, and optionally set it as the
--   root branch.
pushGitBranch :: Codebase m v a -> Branch m -> WriteRepo -> PushGitBranchOpts -> m (Either GitError ())
data PushGitBranchOpts
PushGitBranchOpts :: Bool -> SyncMode -> PushGitBranchOpts

-- | Set the branch as root?
[setRoot] :: PushGitBranchOpts -> Bool
[syncMode] :: PushGitBranchOpts -> SyncMode
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath
type SyncToDir m = CodebasePath -> SyncMode -> Branch m -> m ()
addDefsToCodebase :: forall m v a. (Monad m, Var v, Show a) => Codebase m v a -> TypecheckedUnisonFile v a -> m ()

-- | Write all of UCM's dependencies (builtins types and an empty
--   namespace) into the codebase
installUcmDependencies :: forall m. Monad m => Codebase m Symbol Ann -> m ()
toCodeLookup :: Codebase m v a -> CodeLookup v m a
typeLookupForDependencies :: (Monad m, BuiltinAnnotation a) => Codebase m Symbol a -> Set Reference -> m (TypeLookup Symbol a)

module Unison.Codebase.FileCodebase
codebaseExists :: MonadIO m => CodebasePath -> m Bool

module Unison.Util.SyntaxText
type SyntaxText' r = AnnotatedText (Element r)
data Element r
NumericLiteral :: Element r
TextLiteral :: Element r
BytesLiteral :: Element r
CharLiteral :: Element r
BooleanLiteral :: Element r
Blank :: Element r
Var :: Element r
TypeReference :: r -> Element r
TermReference :: Referent' r -> Element r
Op :: SeqOp -> Element r
AbilityBraces :: Element r
ControlKeyword :: Element r
TypeOperator :: Element r
BindingEquals :: Element r
TypeAscriptionColon :: Element r
DataTypeKeyword :: Element r
DataTypeParams :: Element r
Unit :: Element r
DataTypeModifier :: Element r
UseKeyword :: Element r
UsePrefix :: Element r
UseSuffix :: Element r
HashQualifier :: HashQualified Name -> Element r
DelayForceChar :: Element r
DelimiterChar :: Element r
Parenthesis :: Element r
LinkKeyword :: Element r
DocDelimiter :: Element r
DocKeyword :: Element r
syntax :: Element r -> SyntaxText' r -> SyntaxText' r
toPlain :: SyntaxText' r -> String
instance GHC.Base.Functor Unison.Util.SyntaxText.Element
instance GHC.Show.Show r => GHC.Show.Show (Unison.Util.SyntaxText.Element r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (Unison.Util.SyntaxText.Element r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Unison.Util.SyntaxText.Element r)

module Unison.Util.ColorText
type ColorText = AnnotatedText Color
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Purple :: Color
Cyan :: Color
White :: Color
HiBlack :: Color
HiRed :: Color
HiGreen :: Color
HiYellow :: Color
HiBlue :: Color
HiPurple :: Color
HiCyan :: Color
HiWhite :: Color
Bold :: Color
Underline :: Color
Invert :: Color -> Color
Background :: Color -> Color -> Color
Default :: Color
style :: Color -> ColorText -> ColorText
toANSI :: ColorText -> String
toPlain :: ColorText -> String
toHTML :: String -> ColorText -> String
defaultColors :: Element r -> Maybe Color
black :: ColorText -> ColorText
red :: ColorText -> ColorText
green :: ColorText -> ColorText
yellow :: ColorText -> ColorText
blue :: ColorText -> ColorText
purple :: ColorText -> ColorText
cyan :: ColorText -> ColorText
white :: ColorText -> ColorText
hiBlack :: ColorText -> ColorText
hiRed :: ColorText -> ColorText
hiGreen :: ColorText -> ColorText
hiYellow :: ColorText -> ColorText
hiBlue :: ColorText -> ColorText
hiPurple :: ColorText -> ColorText
hiCyan :: ColorText -> ColorText
hiWhite :: ColorText -> ColorText
bold :: ColorText -> ColorText
underline :: ColorText -> ColorText
invert :: ColorText -> ColorText
background :: Color -> ColorText -> ColorText
unstyled :: ColorText -> ColorText
newtype AnnotatedText a
AnnotatedText :: Seq (Segment a) -> AnnotatedText a
data Segment a
Segment :: String -> Maybe a -> Segment a
[segment] :: Segment a -> String
[annotation] :: Segment a -> Maybe a
toPair :: Segment a -> (String, Maybe a)
annotate :: a -> AnnotatedText a -> AnnotatedText a
instance GHC.Read.Read Unison.Util.ColorText.Color
instance GHC.Show.Show Unison.Util.ColorText.Color
instance GHC.Classes.Ord Unison.Util.ColorText.Color
instance GHC.Classes.Eq Unison.Util.ColorText.Color

module Unison.Util.Pretty
data Pretty s
type ColorText = ColorText
align :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> [Pretty s]
align' :: (ListLike s Char, IsString s) => [(Pretty s, Maybe (Pretty s))] -> [(Pretty s, Pretty s)]
alternations :: ListLike s c => (c -> Bool) -> s -> [s]
background :: (Pretty ColorText -> Pretty ColorText) -> Pretty ColorText -> Pretty ColorText
backticked :: IsString s => Pretty s -> Pretty s

-- | Attach some punctuation after the closing backtick.
backticked' :: IsString s => Pretty s -> Pretty s -> Pretty s
boxForkLeft :: forall s. (ListLike s Char, IsString s) => [Pretty s] -> [Pretty s]
boxLeft :: forall s. (ListLike s Char, IsString s) => [Pretty s] -> [Pretty s]
boxLeftM :: forall m s. (Monad m, ListLike s Char, IsString s) => [m (Pretty s)] -> [m (Pretty s)]
boxRight :: forall s. (ListLike s Char, IsString s) => [Pretty s] -> [Pretty s]
boxRightM :: forall m s. (Monad m, ListLike s Char, IsString s) => [m (Pretty s)] -> [m (Pretty s)]
bulleted :: (Foldable f, ListLike s Char, IsString s) => f (Pretty s) -> Pretty s
bracket :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
callout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
excerptSep :: IsString s => Maybe Int -> Pretty s -> [Pretty s] -> Pretty s
excerptSep' :: IsString s => Maybe Int -> (Int -> Pretty s) -> Pretty s -> [Pretty s] -> Pretty s
excerptColumn2 :: (ListLike s Char, IsString s) => Maybe Int -> [(Pretty s, Pretty s)] -> Pretty s
excerptColumn2Headed :: (ListLike s Char, IsString s) => Maybe Int -> (Pretty s, Pretty s) -> [(Pretty s, Pretty s)] -> Pretty s
warnCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
blockedCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
fatalCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
okCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
column2 :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> Pretty s
column2sep :: (ListLike s Char, IsString s) => Pretty s -> [(Pretty s, Pretty s)] -> Pretty s
column2Header :: Pretty ColorText -> Pretty ColorText -> [(Pretty ColorText, Pretty ColorText)] -> Pretty ColorText
column2M :: (Applicative m, ListLike s Char, IsString s) => [m (Pretty s, Pretty s)] -> m (Pretty s)
column2UnzippedM :: forall m s. (ListLike s Char, IsString s, Monad m) => Pretty s -> [m (Pretty s)] -> [m (Pretty s)] -> m (Pretty s)
column3 :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s, Pretty s)] -> Pretty s
column3M :: (ListLike s Char, IsString s, Monad m) => [m (Pretty s, Pretty s, Pretty s)] -> m (Pretty s)
column3UnzippedM :: forall m s. (ListLike s Char, IsString s, Monad m) => Pretty s -> [m (Pretty s)] -> [m (Pretty s)] -> [m (Pretty s)] -> m (Pretty s)
column3sep :: (ListLike s Char, IsString s) => Pretty s -> [(Pretty s, Pretty s, Pretty s)] -> Pretty s
commas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
commented :: (Foldable f, ListLike s Char, IsString s) => f (Pretty s) -> Pretty s
oxfordCommas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
oxfordCommasWith :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
plural :: Foldable f => f a -> Pretty ColorText -> Pretty ColorText
dashed :: (Foldable f, ListLike s Char, IsString s) => f (Pretty s) -> Pretty s
flatMap :: (s -> Pretty s2) -> Pretty s -> Pretty s2
group :: Pretty s -> Pretty s
hang' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
hang :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
hangUngrouped' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
hangUngrouped :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
softHang' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
softHang :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
softHangNoSpace' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
indent :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
indentAfterNewline :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
indentN :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
indentNonEmptyN :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
indentNAfterNewline :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
invert :: Pretty ColorText -> Pretty ColorText
isMultiLine :: Pretty s -> Bool
isEmpty :: Eq s => IsString s => Pretty s -> Bool
leftPad :: IsString s => Width -> Pretty s -> Pretty s
lines :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
linesNonEmpty :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
linesSpaced :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
lit :: (IsString s, ListLike s Char) => s -> Pretty s
map :: ListLike s2 Char => (s -> s2) -> Pretty s -> Pretty s2
mayColumn2 :: (ListLike s Char, IsString s) => [(Pretty s, Maybe (Pretty s))] -> Pretty s
nest :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
num :: (Show n, Num n, IsString s) => n -> Pretty s
newline :: IsString s => Pretty s
leftJustify :: (Eq s, Show s, ListLike s Char, IsString s) => [(Pretty s, a)] -> [(Pretty s, a)]
lineSkip :: IsString s => Pretty s
nonEmpty :: (Foldable f, IsString s) => f (Pretty s) -> [Pretty s]
numbered :: (Foldable f, ListLike s Char, IsString s) => (Int -> Pretty s) -> f (Pretty s) -> Pretty s
numberedColumn2 :: (Foldable f, ListLike s Char, IsString s) => (Int -> Pretty s) -> f (Pretty s, Pretty s) -> Pretty s
numberedColumn2Header :: (Foldable f, ListLike s Char, IsString s) => (Int -> Pretty s) -> f (Pretty s, Pretty s) -> Pretty s
numberedList :: Foldable f => f (Pretty ColorText) -> Pretty ColorText
orElse :: Pretty s -> Pretty s -> Pretty s
orElses :: [Pretty s] -> Pretty s
paragraphyText :: (ListLike s Char, IsString s) => Text -> Pretty s
parenthesize :: IsString s => Pretty s -> Pretty s
parenthesizeCommas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
parenthesizeIf :: IsString s => Bool -> Pretty s -> Pretty s
render :: (Monoid s, IsString s) => Width -> Pretty s -> s
renderUnbroken :: (Monoid s, IsString s) => Pretty s -> s
rightPad :: IsString s => Width -> Pretty s -> Pretty s
sep :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
sepNonEmpty :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
sepSpaced :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
shown :: (Show a, IsString s) => a -> Pretty s
singleQuoted :: IsString s => Pretty s -> Pretty s
singleQuoted' :: IsString s => Pretty s -> Pretty s -> Pretty s
softbreak :: IsString s => Pretty s
spaceIfBreak :: IsString s => Pretty s
spaceIfNeeded :: Eq s => IsString s => Pretty s -> Pretty s -> Pretty s
spaced :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
spacedMap :: (Foldable f, IsString s) => (a -> Pretty s) -> f a -> Pretty s
spacesIfBreak :: IsString s => Int -> Pretty s
string :: IsString s => String -> Pretty s
surroundCommas :: (Foldable f, IsString s) => Pretty s -> Pretty s -> f (Pretty s) -> Pretty s
syntaxToColor :: Pretty (SyntaxText' r) -> Pretty ColorText
table :: (IsString s, ListLike s Char) => [[Pretty s]] -> Pretty s
text :: IsString s => Text -> Pretty s
toANSI :: Width -> Pretty ColorText -> String
toAnsiUnbroken :: Pretty ColorText -> String
toHTML :: String -> Width -> Pretty ColorText -> String
toPlain :: Width -> Pretty ColorText -> String
toPlainUnbroken :: Pretty ColorText -> String
underline :: Pretty ColorText -> Pretty ColorText
withSyntax :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)
wrap :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
wrap' :: IsString s => (s -> [Pretty s]) -> Pretty s -> Pretty s
wrapColumn2 :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> Pretty s
wrapString :: (ListLike s Char, IsString s) => String -> Pretty s
black :: Pretty ColorText -> Pretty ColorText
red :: Pretty ColorText -> Pretty ColorText
green :: Pretty ColorText -> Pretty ColorText
yellow :: Pretty ColorText -> Pretty ColorText
blue :: Pretty ColorText -> Pretty ColorText
purple :: Pretty ColorText -> Pretty ColorText
cyan :: Pretty ColorText -> Pretty ColorText
white :: Pretty ColorText -> Pretty ColorText
hiBlack :: Pretty ColorText -> Pretty ColorText
hiRed :: Pretty ColorText -> Pretty ColorText
hiGreen :: Pretty ColorText -> Pretty ColorText
hiYellow :: Pretty ColorText -> Pretty ColorText
hiBlue :: Pretty ColorText -> Pretty ColorText
hiPurple :: Pretty ColorText -> Pretty ColorText
hiCyan :: Pretty ColorText -> Pretty ColorText
hiWhite :: Pretty ColorText -> Pretty ColorText
bold :: Pretty ColorText -> Pretty ColorText
border :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
newtype Width
Width :: Int -> Width
[widthToInt] :: Width -> Int
delta :: Pretty s -> Delta
data Delta
instance GHC.Enum.Bounded Unison.Util.Pretty.Width
instance GHC.Num.Num Unison.Util.Pretty.Width
instance GHC.Generics.Generic Unison.Util.Pretty.Width
instance GHC.Show.Show Unison.Util.Pretty.Width
instance GHC.Classes.Ord Unison.Util.Pretty.Width
instance GHC.Classes.Eq Unison.Util.Pretty.Width
instance GHC.Base.Functor (Unison.Util.Pretty.F s)
instance Data.Traversable.Traversable (Unison.Util.Pretty.F s)
instance Data.Foldable.Foldable (Unison.Util.Pretty.F s)
instance (GHC.Show.Show r, GHC.Show.Show s) => GHC.Show.Show (Unison.Util.Pretty.F s r)
instance (GHC.Classes.Eq r, GHC.Classes.Eq s) => GHC.Classes.Eq (Unison.Util.Pretty.F s r)
instance GHC.Show.Show Unison.Util.Pretty.Delta
instance GHC.Classes.Ord Unison.Util.Pretty.Delta
instance GHC.Classes.Eq Unison.Util.Pretty.Delta
instance GHC.Classes.Eq s => GHC.Classes.Eq (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Functor Unison.Util.Pretty.Pretty
instance Data.String.IsString s => Data.String.IsString (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Semigroup (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Monoid (Unison.Util.Pretty.Pretty s)
instance GHC.Show.Show s => GHC.Show.Show (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Semigroup Unison.Util.Pretty.Delta
instance GHC.Base.Monoid Unison.Util.Pretty.Delta

module Unison.Codebase.Runtime
type Error = Pretty ColorText
type Term v = Term v ()
data Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error (Term v))) -> (CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> Type v Ann -> Runtime v
[terminate] :: Runtime v -> IO ()
[evaluate] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error (Term v))
[compileTo] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[mainType] :: Runtime v -> Type v Ann
[ioTestType] :: Runtime v -> Type v Ann
type IsCacheHit = Bool
noCache :: Id -> IO (Maybe (Term v))
type WatchResults v a = (Either Error ([(v, Term v)], Map v (a, WatchKind, Id, Term v, Term v, IsCacheHit)))
evaluateWatches :: forall v a. Var v => CodeLookup v IO a -> PrettyPrintEnv -> (Id -> IO (Maybe (Term v))) -> Runtime v -> TypecheckedUnisonFile v a -> IO (WatchResults v a)
evaluateTerm' :: (Var v, Monoid a) => CodeLookup v IO a -> (Id -> IO (Maybe (Term v))) -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error (Term v))
evaluateTerm :: (Var v, Monoid a) => CodeLookup v IO a -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error (Term v))


-- | Open codebase error type.
module Unison.Codebase.Init.OpenCodebaseError

-- | An error that can occur when attempting to open a codebase.
data OpenCodebaseError

-- | The codebase doesn't exist.
OpenCodebaseDoesntExist :: OpenCodebaseError

-- | The codebase exists, but its schema version is unknown to this
--   application.
OpenCodebaseUnknownSchemaVersion :: Word64 -> OpenCodebaseError
OpenCodebaseOther :: Pretty ColorText -> OpenCodebaseError
instance GHC.Show.Show Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError

module Unison.Codebase.Init.CreateCodebaseError
data CreateCodebaseError
CreateCodebaseAlreadyExists :: CreateCodebaseError
CreateCodebaseOther :: Pretty -> CreateCodebaseError
type Pretty = Pretty ColorText

module Unison.Codebase.Init.Type
data Init m v a
Init :: (DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))) -> (DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[openCodebase] :: Init m v a -> DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))

-- | create a new codebase
[createCodebase'] :: Init m v a -> DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[codebasePath] :: Init m v a -> CodebasePath -> CodebasePath

module Unison.PrettyTerminal
stripSurroundingBlanks :: String -> String
putPrettyLn :: Pretty ColorText -> IO ()
putPrettyLnUnpaged :: Pretty ColorText -> IO ()
putPrettyLn' :: Pretty ColorText -> IO ()
clearCurrentLine :: IO ()
putPretty' :: Pretty ColorText -> IO ()
getAvailableWidth :: IO Width
putPrettyNonempty :: Pretty ColorText -> IO ()

module Unison.Codebase.Init
data Init m v a
Init :: (forall r. DebugName -> CodebasePath -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)) -> (forall r. DebugName -> CodebasePath -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[withOpenCodebase] :: Init m v a -> forall r. DebugName -> CodebasePath -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)

-- | create a new codebase
[withCreatedCodebase] :: Init m v a -> forall r. DebugName -> CodebasePath -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[codebasePath] :: Init m v a -> CodebasePath -> CodebasePath
type DebugName = String

-- | An error that occurred while initializing a codebase.
data InitError
FoundV1Codebase :: InitError
InitErrorOpen :: OpenCodebaseError -> InitError
CouldntCreateCodebase :: Pretty -> InitError
data CodebaseInitOptions
Home :: CodebasePath -> CodebaseInitOptions
Specified :: SpecifiedCodebase -> CodebaseInitOptions
data InitResult
OpenedCodebase :: InitResult
CreatedCodebase :: InitResult
data SpecifiedCodebase
CreateWhenMissing :: CodebasePath -> SpecifiedCodebase
DontCreateWhenMissing :: CodebasePath -> SpecifiedCodebase
type Pretty = Pretty ColorText
createCodebase :: MonadIO m => Init m v a -> DebugName -> CodebasePath -> (Codebase m v a -> m r) -> m (Either Pretty r)

-- | try to init a codebase where none exists and then exit regardless
--   (i.e. `ucm --codebase dir init`)
initCodebaseAndExit :: MonadIO m => Init m Symbol Ann -> DebugName -> Maybe CodebasePath -> m ()
withOpenOrCreateCodebase :: MonadIO m => Init m v a -> DebugName -> CodebaseInitOptions -> ((InitResult, CodebasePath, Codebase m v a) -> m r) -> m (Either (CodebasePath, InitError) r)
withNewUcmCodebaseOrExit :: MonadIO m => Init m Symbol Ann -> DebugName -> CodebasePath -> (Codebase m Symbol Ann -> m r) -> m r
instance GHC.Classes.Eq Unison.Codebase.Init.InitResult
instance GHC.Show.Show Unison.Codebase.Init.InitResult

module Unison.Codebase.SqliteCodebase
init :: HasCallStack => MonadUnliftIO m => Init m Symbol Ann
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.SqliteCodebase.BufferEntry a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.BufferEntry a)
instance GHC.Show.Show (Unison.Codebase.SqliteCodebase.Entity m)


-- | Duplicate of the Unison.Util.SyntaxText module, but we expect these to
--   evolve separately. This is the version which is outward facing to the
--   server frontend.
module Unison.Server.Syntax
type SyntaxText = AnnotatedText Element
type SyntaxSegment = Segment Element
convertElement :: Element Reference -> Element
type UnisonHash = Text
type HashQualifiedName = Text

-- | The elements of the Unison grammar, for syntax highlighting purposes
data Element
NumericLiteral :: Element
TextLiteral :: Element
BytesLiteral :: Element
CharLiteral :: Element
BooleanLiteral :: Element
Blank :: Element
Var :: Element
TypeReference :: UnisonHash -> Element
DataConstructorReference :: UnisonHash -> Element
AbilityConstructorReference :: UnisonHash -> Element
TermReference :: UnisonHash -> Element
Op :: SeqOp -> Element

-- | Constructor Are these even used? | Request
AbilityBraces :: Element
ControlKeyword :: Element
TypeOperator :: Element
BindingEquals :: Element
TypeAscriptionColon :: Element
DataTypeKeyword :: Element
DataTypeParams :: Element
Unit :: Element
DataTypeModifier :: Element
UseKeyword :: Element
UsePrefix :: Element
UseSuffix :: Element
HashQualifier :: HashQualifiedName -> Element
DelayForceChar :: Element
DelimiterChar :: Element
Parenthesis :: Element
LinkKeyword :: Element
DocDelimiter :: Element
DocKeyword :: Element
syntax :: Element -> SyntaxText -> SyntaxText
firstReference :: SyntaxText -> Maybe UnisonHash
reference :: SyntaxSegment -> Maybe UnisonHash

-- | Convert a <a>SyntaxText</a> to a <a>String</a>, ignoring syntax markup
toPlain :: SyntaxText -> String
toHtml :: SyntaxText -> Html ()
nameToHtml :: Name -> Html ()
segmentToHtml :: SyntaxSegment -> Html ()
elementToClassName :: Element -> Text
instance GHC.Generics.Generic Unison.Server.Syntax.Element
instance GHC.Show.Show Unison.Server.Syntax.Element
instance GHC.Classes.Ord Unison.Server.Syntax.Element
instance GHC.Classes.Eq Unison.Server.Syntax.Element
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Syntax.Element
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Unison.Util.AnnotatedText.Segment a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Pattern.SeqOp
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Syntax.SyntaxText
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Syntax.SyntaxText
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Syntax.Element
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Unison.Util.AnnotatedText.Segment a)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Pattern.SeqOp
instance Data.OpenApi.Internal.Schema.ToSchema r => Data.OpenApi.Internal.Schema.ToSchema (Data.Sequence.Internal.Seq r)

module Unison.NamePrinter
type SyntaxText = SyntaxText' Reference
prettyName :: IsString s => Name -> Pretty s
prettyHashQualified :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified' :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified0 :: IsString s => HashQualified Name -> Pretty s

-- | Pretty-print a reference as a name and the given number of characters
--   of its hash.
prettyNamedReference :: Int -> Name -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as a name and the given number of characters
--   of its hash.
prettyNamedReferent :: Int -> Name -> Referent -> Pretty SyntaxText

-- | Pretty-print a reference as the given number of characters of its
--   hash.
prettyReference :: Int -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as the given number of characters of its hash.
prettyReferent :: Int -> Referent -> Pretty SyntaxText
prettyLabeledDependency :: Int -> LabeledDependency -> Pretty SyntaxText
prettyShortHash :: IsString s => ShortHash -> Pretty s
styleHashQualified :: IsString s => (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified' :: IsString s => (Pretty s -> Pretty s) -> (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified'' :: (Pretty SyntaxText -> Pretty SyntaxText) -> HashQualified Name -> Pretty SyntaxText
fmt :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)

module Unison.Util.Find
fuzzyFinder :: forall a. String -> [a] -> (a -> String) -> [(a, Pretty ColorText)]
simpleFuzzyFinder :: forall a. String -> [a] -> (a -> String) -> [(a, Pretty ColorText)]
simpleFuzzyScore :: String -> String -> Maybe Int
fuzzyFindInBranch :: HasCallStack => Names -> HashQualified Name -> [(SearchResult, Pretty ColorText)]
fuzzyFindMatchArray :: forall a. String -> [a] -> (a -> String) -> [(MatchArray, (a, Pretty ColorText))]
prefixFindInBranch :: Names -> HashQualified Name -> [(SearchResult, Pretty ColorText)]

module Unison.TypePrinter
pretty :: forall v a. Var v => PrettyPrintEnv -> Type v a -> Pretty ColorText
pretty0 :: forall v a. Var v => PrettyPrintEnv -> Imports -> Int -> Type v a -> Pretty SyntaxText
prettyRaw :: forall v a. Var v => PrettyPrintEnv -> Imports -> Int -> Type v a -> Pretty SyntaxText
prettyStr :: Var v => Maybe Width -> PrettyPrintEnv -> Type v a -> String
prettySyntax :: forall v a. Var v => PrettyPrintEnv -> Type v a -> Pretty SyntaxText
prettySignaturesST :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty SyntaxText]
prettySignaturesCT :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty ColorText]
prettySignaturesCTCollapsed :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> Pretty ColorText
prettySignaturesAlt :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> Pretty ColorText
prettySignaturesAlt' :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> [Pretty ColorText]

module Unison.Typechecker.Context

-- | public interface to the typechecker
synthesizeClosed :: (Var v, Ord loc) => [Type v loc] -> TypeLookup v loc -> Term v loc -> Result v loc (Type v loc)
data ErrorNote v loc
ErrorNote :: Cause v loc -> Seq (PathElement v loc) -> ErrorNote v loc
[cause] :: ErrorNote v loc -> Cause v loc
[path] :: ErrorNote v loc -> Seq (PathElement v loc)
data CompilerBug v loc
UnknownDecl :: Unknown -> Reference -> Map Reference (DataDeclaration v loc) -> CompilerBug v loc
UnknownConstructor :: Unknown -> ConstructorReference -> DataDeclaration v loc -> CompilerBug v loc
UndeclaredTermVariable :: v -> Context v loc -> CompilerBug v loc
RetractFailure :: Element v loc -> Context v loc -> CompilerBug v loc
EmptyLetRec :: Term v loc -> CompilerBug v loc
PatternMatchFailure :: CompilerBug v loc
EffectConstructorHadMultipleEffects :: Type v loc -> CompilerBug v loc
FreeVarsInTypeAnnotation :: Set (TypeVar v loc) -> CompilerBug v loc
UnannotatedReference :: Reference -> CompilerBug v loc
MalformedPattern :: Pattern loc -> CompilerBug v loc
UnknownTermReference :: Reference -> CompilerBug v loc
UnknownExistentialVariable :: v -> Context v loc -> CompilerBug v loc
IllegalContextExtension :: Context v loc -> Element v loc -> String -> CompilerBug v loc
OtherBug :: String -> CompilerBug v loc
data InfoNote v loc
SolvedBlank :: Recorded loc -> v -> Type v loc -> InfoNote v loc
Decision :: v -> loc -> Term v loc -> InfoNote v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> InfoNote v loc
data Cause v loc
TypeMismatch :: Context v loc -> Cause v loc
IllFormedType :: Context v loc -> Cause v loc
UnknownSymbol :: loc -> v -> Cause v loc
UnknownTerm :: loc -> v -> [Suggestion v loc] -> Type v loc -> Cause v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
EffectConstructorWrongArgCount :: ExpectedArgCount -> ActualArgCount -> ConstructorReference -> Cause v loc
MalformedEffectBind :: Type v loc -> Type v loc -> [Type v loc] -> Cause v loc
PatternArityMismatch :: loc -> Type v loc -> Int -> Cause v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> Cause v loc
UnguardedLetRecCycle :: [v] -> [(v, Term v loc)] -> Cause v loc
ConcatPatternWithoutConstantLength :: loc -> Type v loc -> Cause v loc
HandlerOfUnexpectedType :: loc -> Type v loc -> Cause v loc
DataEffectMismatch :: Unknown -> Reference -> DataDeclaration v loc -> Cause v loc
newtype Context v loc
Context :: [(Element v loc, Info v loc)] -> Context v loc
type ActualArgCount = Int
type ExpectedArgCount = Int
type ConstructorId = Int

-- | Elements of an ordered algorithmic context
data Element v loc

-- | A variable declaration
Var :: TypeVar v loc -> Element v loc

-- | <tt>v</tt> is solved to some monotype
Solved :: Blank loc -> v -> Monotype v loc -> Element v loc

-- | <tt>v</tt> has type <tt>a</tt>, maybe quantified
Ann :: v -> Type v loc -> Element v loc

-- | used for scoping
Marker :: v -> Element v loc
data PathElement v loc
InSynthesize :: Term v loc -> PathElement v loc
InSubtype :: Type v loc -> Type v loc -> PathElement v loc
InEquate :: Type v loc -> Type v loc -> PathElement v loc
InCheck :: Term v loc -> Type v loc -> PathElement v loc
InInstantiateL :: v -> Type v loc -> PathElement v loc
InInstantiateR :: Type v loc -> v -> PathElement v loc
InSynthesizeApp :: Type v loc -> Term v loc -> Int -> PathElement v loc
InFunctionCall :: [v] -> Term v loc -> Type v loc -> [Term v loc] -> PathElement v loc
InAndApp :: PathElement v loc
InOrApp :: PathElement v loc
InIfCond :: PathElement v loc
InIfBody :: loc -> PathElement v loc
InVectorApp :: loc -> PathElement v loc
InMatch :: loc -> PathElement v loc
InMatchGuard :: PathElement v loc
InMatchBody :: PathElement v loc
type Term v loc = Term' (TypeVar v loc) v loc
type Type v loc = Type (TypeVar v loc) loc
type TypeVar v loc = TypeVar (Blank loc) v
data Result v loc a
Success :: Seq (InfoNote v loc) -> a -> Result v loc a
TypeError :: NESeq (ErrorNote v loc) -> Seq (InfoNote v loc) -> Result v loc a
CompilerBug :: CompilerBug v loc -> Seq (ErrorNote v loc) -> Seq (InfoNote v loc) -> Result v loc a
errorTerms :: ErrorNote v loc -> [Term v loc]
innermostErrorTerm :: ErrorNote v loc -> Maybe (Term v loc)
lookupAnn :: Ord v => Context v loc -> v -> Maybe (Type v loc)
lookupSolved :: Ord v => Context v loc -> v -> Maybe (Monotype v loc)

-- | Replace any existentials with their solution in the context
apply :: (Var v, Ord loc) => Context v loc -> Type v loc -> Type v loc
isEqual :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isSubtype :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isRedundant :: (Var v, Ord loc) => Type v loc -> Type v loc -> M v loc Bool
data Suggestion v loc
Suggestion :: Text -> Type v loc -> Either v Referent -> SuggestionMatch -> Suggestion v loc
[suggestionName] :: Suggestion v loc -> Text
[suggestionType] :: Suggestion v loc -> Type v loc
[suggestionReplacement] :: Suggestion v loc -> Either v Referent
[suggestionMatch] :: Suggestion v loc -> SuggestionMatch
data SuggestionMatch
Exact :: SuggestionMatch
WrongType :: SuggestionMatch
WrongName :: SuggestionMatch
isExact :: Suggestion v loc -> Bool
typeErrors :: Result v loc a -> Seq (ErrorNote v loc)
infoNotes :: Result v loc a -> Seq (InfoNote v loc)
data Unknown
Data :: Unknown
Effect :: Unknown
relax :: Var v => Ord loc => Type v loc -> Type v loc
instance GHC.Show.Show Unison.Typechecker.Context.Unknown
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.Typechecker.Context.PathElement v loc)
instance GHC.Show.Show Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Eq Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Ord Unison.Typechecker.Context.SuggestionMatch
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.Context.Suggestion v loc)
instance Unison.ABT.Var v => GHC.Classes.Eq (Unison.Typechecker.Context.Suggestion v loc)
instance (GHC.Show.Show loc, GHC.Show.Show v) => GHC.Show.Show (Unison.Typechecker.Context.InfoNote v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.Cause v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.ErrorNote v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.CompilerBug v loc)
instance GHC.Base.Functor (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Monad f => GHC.Base.Monad (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.Fail.MonadFail (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => GHC.Base.Applicative (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.Reader.Class.MonadReader (Unison.Typechecker.Context.MEnv v loc) (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Applicative (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Monad (Unison.Typechecker.Context.Result v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Show.Show (Unison.Typechecker.Context.Context v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Classes.Eq (Unison.Typechecker.Context.Element v loc)
instance Unison.Var.Var v => GHC.Show.Show (Unison.Typechecker.Context.Element v loc)

module Unison.Typechecker.Extractor
type RedundantTypeAnnotation = Bool
type Extractor e a = MaybeT (Reader e) a
type ErrorExtractor v loc a = Extractor (ErrorNote v loc) a
type InfoExtractor v loc a = Extractor (InfoNote v loc) a
type PathExtractor v loc a = Extractor (PathElement v loc) a
type SubseqExtractor v loc a = SubseqExtractor' (ErrorNote v loc) a
extractor :: (e -> Maybe a) -> Extractor e a
extract :: Extractor e a -> e -> Maybe a
subseqExtractor :: (ErrorNote v loc -> [Ranged a]) -> SubseqExtractor v loc a
traceSubseq :: Show a => String -> SubseqExtractor' n a -> SubseqExtractor' n a
traceNote :: Show a => String -> ErrorExtractor v loc a -> ErrorExtractor v loc a
unique :: SubseqExtractor v loc a -> ErrorExtractor v loc a
data SubseqExtractor' n a
SubseqExtractor' :: (n -> [Ranged a]) -> SubseqExtractor' n a
[runSubseq] :: SubseqExtractor' n a -> n -> [Ranged a]
data Ranged a
Pure :: a -> Ranged a
Ranged :: a -> Int -> Int -> Ranged a
[get] :: Ranged a -> a
[start] :: Ranged a -> Int
[end] :: Ranged a -> Int

-- | collects the regions where <tt>xa</tt> doesn't match / aka invert a
--   set of intervals unused, but don't want to delete it yet - Aug 30,
--   2018
_no :: SubseqExtractor' n a -> SubseqExtractor' n ()
_any :: SubseqExtractor v loc ()
_any' :: (n -> Int) -> SubseqExtractor' n ()
data DistinctRanged a
DistinctRanged :: a -> Int -> Int -> DistinctRanged a
some :: forall n a. SubseqExtractor' n a -> SubseqExtractor' n [a]
pathStart :: SubseqExtractor' n ()
asPathExtractor :: (PathElement v loc -> Maybe a) -> SubseqExtractor v loc a
inSynthesize :: SubseqExtractor v loc (Term v loc)
inSubtype :: SubseqExtractor v loc (Type v loc, Type v loc)
inCheck :: SubseqExtractor v loc (Term v loc, Type v loc)
inSynthesizeApp :: SubseqExtractor v loc (Type v loc, Term v loc, Int)
inFunctionCall :: SubseqExtractor v loc ([v], Term v loc, Type v loc, [Term v loc])
inAndApp :: SubseqExtractor v loc ()
inOrApp :: SubseqExtractor v loc ()
inIfCond :: SubseqExtractor v loc ()
inMatchGuard :: SubseqExtractor v loc ()
inMatchBody :: SubseqExtractor v loc ()
inMatch :: SubseqExtractor v loc loc
inVector :: SubseqExtractor v loc loc
inIfBody :: SubseqExtractor v loc loc
cause :: ErrorExtractor v loc (Cause v loc)
duplicateDefinitions :: ErrorExtractor v loc (NonEmpty (v, [loc]))
typeMismatch :: ErrorExtractor v loc (Context v loc)
illFormedType :: ErrorExtractor v loc (Context v loc)
unknownSymbol :: ErrorExtractor v loc (loc, v)
unknownTerm :: Var v => ErrorExtractor v loc (loc, v, [Suggestion v loc], Type v loc)
abilityCheckFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
effectConstructorWrongArgCount :: ErrorExtractor v loc (ExpectedArgCount, ActualArgCount, ConstructorReference)
malformedEffectBind :: ErrorExtractor v loc (Type v loc, Type v loc, [Type v loc])
solvedBlank :: InfoExtractor v loc (Recorded loc, v, Type v loc)
errorNote :: ErrorExtractor v loc (ErrorNote v loc)
infoNote :: InfoExtractor v loc (InfoNote v loc)
innermostTerm :: ErrorExtractor v loc (Term v loc)
path :: ErrorExtractor v loc [PathElement v loc]
topLevelComponent :: InfoExtractor v loc [(v, Type v loc, RedundantTypeAnnotation)]
instance GHC.Show.Show a => GHC.Show.Show (Unison.Typechecker.Extractor.Ranged a)
instance GHC.Base.Functor Unison.Typechecker.Extractor.Ranged
instance GHC.Classes.Eq (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Classes.Ord (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Base.Functor (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Applicative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance Control.Monad.Fail.MonadFail (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monad (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Alternative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.MonadPlus (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monoid (Unison.Typechecker.Extractor.SubseqExtractor' n a)
instance GHC.Base.Semigroup (Unison.Typechecker.Extractor.SubseqExtractor' n a)

module Unison.Typechecker.TypeError
data BooleanMismatch
CondMismatch :: BooleanMismatch
AndMismatch :: BooleanMismatch
OrMismatch :: BooleanMismatch
GuardMismatch :: BooleanMismatch
data ExistentialMismatch
IfBody :: ExistentialMismatch
VectorBody :: ExistentialMismatch
CaseBody :: ExistentialMismatch
data TypeError v loc
Mismatch :: Type v loc -> Type v loc -> Type v loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[foundType] :: TypeError v loc -> Type v loc
[expectedType] :: TypeError v loc -> Type v loc
[foundLeaf] :: TypeError v loc -> Type v loc
[expectedLeaf] :: TypeError v loc -> Type v loc
[mismatchSite] :: TypeError v loc -> Term v loc
[note] :: TypeError v loc -> ErrorNote v loc
BooleanMismatch :: BooleanMismatch -> Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[getBooleanMismatch] :: TypeError v loc -> BooleanMismatch
[mismatchSite] :: TypeError v loc -> Term v loc
[foundType] :: TypeError v loc -> Type v loc
[note] :: TypeError v loc -> ErrorNote v loc
ExistentialMismatch :: ExistentialMismatch -> Type v loc -> loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[getExistentialMismatch] :: TypeError v loc -> ExistentialMismatch
[expectedType] :: TypeError v loc -> Type v loc
[expectedLoc] :: TypeError v loc -> loc
[foundType] :: TypeError v loc -> Type v loc
[mismatchSite] :: TypeError v loc -> Term v loc
[note] :: TypeError v loc -> ErrorNote v loc
FunctionApplication :: Term v loc -> Type v loc -> Term v loc -> Int -> Type v loc -> Type v loc -> Maybe (Type v loc, Type v loc) -> [(v, Type v loc)] -> ErrorNote v loc -> TypeError v loc
[f] :: TypeError v loc -> Term v loc
[ft] :: TypeError v loc -> Type v loc
[arg] :: TypeError v loc -> Term v loc
[argNum] :: TypeError v loc -> Int
[foundType] :: TypeError v loc -> Type v loc
[expectedType] :: TypeError v loc -> Type v loc
[leafs] :: TypeError v loc -> Maybe (Type v loc, Type v loc)
[solvedVars] :: TypeError v loc -> [(v, Type v loc)]
[note] :: TypeError v loc -> ErrorNote v loc
NotFunctionApplication :: Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[f] :: TypeError v loc -> Term v loc
[ft] :: TypeError v loc -> Type v loc
[note] :: TypeError v loc -> ErrorNote v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> loc -> ErrorNote v loc -> TypeError v loc
[ambient] :: TypeError v loc -> [Type v loc]
[requested] :: TypeError v loc -> [Type v loc]
[abilityCheckFailureSite] :: TypeError v loc -> loc
[note] :: TypeError v loc -> ErrorNote v loc
UnguardedLetRecCycle :: [v] -> [loc] -> ErrorNote v loc -> TypeError v loc
[cycle] :: TypeError v loc -> [v]
[cycleLocs] :: TypeError v loc -> [loc]
[note] :: TypeError v loc -> ErrorNote v loc
UnknownType :: v -> loc -> ErrorNote v loc -> TypeError v loc
[unknownTypeV] :: TypeError v loc -> v
[typeSite] :: TypeError v loc -> loc
[note] :: TypeError v loc -> ErrorNote v loc
UnknownTerm :: v -> loc -> [Suggestion v loc] -> Type v loc -> ErrorNote v loc -> TypeError v loc
[unknownTermV] :: TypeError v loc -> v
[termSite] :: TypeError v loc -> loc
[suggestions] :: TypeError v loc -> [Suggestion v loc]
[expectedType] :: TypeError v loc -> Type v loc
[note] :: TypeError v loc -> ErrorNote v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> ErrorNote v loc -> TypeError v loc
[defns] :: TypeError v loc -> NonEmpty (v, [loc])
[note] :: TypeError v loc -> ErrorNote v loc
Other :: ErrorNote v loc -> TypeError v loc
type RedundantTypeAnnotation = Bool
data TypeInfo v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> TypeInfo v loc
[definitions] :: TypeInfo v loc -> [(v, Type v loc, RedundantTypeAnnotation)]
type TypeNote v loc = Either (TypeError v loc) (TypeInfo v loc)
typeErrorFromNote :: (Ord loc, Show loc, Var v) => ErrorNote v loc -> TypeError v loc
typeInfoFromNote :: (Ord loc, Show loc, Var v) => InfoNote v loc -> Maybe (TypeInfo v loc)
allErrors :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
topLevelComponent :: InfoExtractor v a (TypeInfo v a)
abilityCheckFailure :: ErrorExtractor v a (TypeError v a)
duplicateDefinitions :: ErrorExtractor v a (TypeError v a)
unknownType :: ErrorExtractor v loc (TypeError v loc)
unknownTerm :: Var v => ErrorExtractor v loc (TypeError v loc)
generalMismatch :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
and :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
or :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
cond :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchGuard :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
unguardedCycle :: ErrorExtractor v loc (TypeError v loc)

-- | helper function to support <a>and</a> <i> <a>or</a> </i> <a>cond</a>
booleanMismatch0 :: (Var v, Ord loc) => BooleanMismatch -> SubseqExtractor v loc () -> ErrorExtractor v loc (TypeError v loc)
existentialMismatch0 :: (Var v, Ord loc) => ExistentialMismatch -> SubseqExtractor v loc loc -> ErrorExtractor v loc (TypeError v loc)
ifBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
vectorBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
applyingNonFunction :: Var v => ErrorExtractor v loc (TypeError v loc)

-- | Want to collect this info: The <tt>n</tt>th argument to <a>f</a> is
--   <a>foundType</a>, but I was expecting <a>expectedType</a>.
--   
--   30 | asdf asdf asdf
--   
--   If you're curious <a>f</a> has type <tt>blah</tt>, where <tt>a</tt>
--   was chosen as <tt>A</tt> <tt>b</tt> was chosen as <tt>B</tt>
--   <tt>c</tt> was chosen as <tt>C</tt> (many colors / groups)
applyingFunction :: forall v loc. Var v => ErrorExtractor v loc (TypeError v loc)
inSubtypes :: SubseqExtractor v loc (Type v loc, Type v loc, Maybe (Type v loc, Type v loc))
instance GHC.Show.Show Unison.Typechecker.TypeError.BooleanMismatch
instance GHC.Show.Show Unison.Typechecker.TypeError.ExistentialMismatch
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.TypeError.TypeError v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeError.TypeInfo v loc)

module Unison.Result
type Result notes = ResultT notes Identity
type ResultT notes f = MaybeT (WriterT notes f)
data Note v loc
Parsing :: Err v -> Note v loc
NameResolutionFailures :: [ResolutionFailure v loc] -> Note v loc
UnknownSymbol :: v -> loc -> Note v loc
TypeError :: ErrorNote v loc -> Note v loc
TypeInfo :: InfoNote v loc -> Note v loc
CompilerBug :: CompilerBug v loc -> Note v loc
data CompilerBug v loc
TopLevelComponentNotFound :: v -> Term v loc -> CompilerBug v loc
ResolvedNameNotFound :: v -> loc -> Name -> CompilerBug v loc
TypecheckerBug :: CompilerBug v loc -> CompilerBug v loc
result :: Result notes a -> Maybe a
pattern Result :: w -> Maybe a -> MaybeT (WriterT w Identity) a
isSuccess :: Functor f => ResultT note f a -> f Bool
isFailure :: Functor f => ResultT note f a -> f Bool
toMaybe :: Functor f => ResultT note f a -> f (Maybe a)
runResultT :: ResultT notes f a -> f (Maybe a, notes)
getResult :: Functor f => ResultT notes f a -> f (Result notes a)
toEither :: Functor f => ResultT notes f a -> ExceptT notes f a
tell1 :: Monad f => note -> ResultT (Seq note) f ()
fromParsing :: Monad f => Either (Err v) a -> ResultT (Seq (Note v loc)) f a
tellAndFail :: Monad f => note -> ResultT (Seq note) f a
compilerBug :: Monad f => CompilerBug v loc -> ResultT (Seq (Note v loc)) f a
hoist :: (Monad f, Monoid notes) => (forall a. f a -> g a) -> ResultT notes f b -> ResultT notes g b
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.CompilerBug v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.Note v loc)


-- | This module is the primary interface to the Unison typechecker module
--   Unison.Typechecker (admissibleTypeAt, check, check', checkAdmissible',
--   equals, locals, subtype, isSubtype, synthesize, synthesize', typeAt,
--   wellTyped) where
module Unison.Typechecker
type Name = Text
data Notes v loc
Notes :: Seq (CompilerBug v loc) -> Seq (ErrorNote v loc) -> Seq (InfoNote v loc) -> Notes v loc
[bugs] :: Notes v loc -> Seq (CompilerBug v loc)
[errors] :: Notes v loc -> Seq (ErrorNote v loc)
[infos] :: Notes v loc -> Seq (InfoNote v loc)
convertResult :: Result v loc a -> Result (Notes v loc) a
data NamedReference v loc
NamedReference :: Name -> Type v loc -> Either v Referent -> NamedReference v loc
[fqn] :: NamedReference v loc -> Name
[fqnType] :: NamedReference v loc -> Type v loc
[replacement] :: NamedReference v loc -> Either v Referent
data Env v loc
Env :: [Type v loc] -> TypeLookup v loc -> Map Name [NamedReference v loc] -> Env v loc
[_ambientAbilities] :: Env v loc -> [Type v loc]
[_typeLookup] :: Env v loc -> TypeLookup v loc
[_termsByShortname] :: Env v loc -> Map Name [NamedReference v loc]
typeLookup :: forall v_a5CNq loc_a5CNr. Lens' (Env v_a5CNq loc_a5CNr) (TypeLookup v_a5CNq loc_a5CNr)
termsByShortname :: forall v_a5CNq loc_a5CNr. Lens' (Env v_a5CNq loc_a5CNr) (Map Name [NamedReference v_a5CNq loc_a5CNr])
ambientAbilities :: forall v_a5CNq loc_a5CNr. Lens' (Env v_a5CNq loc_a5CNr) [Type v_a5CNq loc_a5CNr]

-- | Infer the type of a <a>Term</a>, using a function to resolve the type
--   of <tt>Ref</tt> constructors contained in that term.
synthesize :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> ResultT (Notes v loc) f (Type v loc)
isSubtype :: Var v => Type v loc -> Type v loc -> Bool
isEqual :: Var v => Type v loc -> Type v loc -> Bool
type TDNR f v loc a = StateT (Term v loc) (ResultT (Notes v loc) f) a
data Resolution v loc
Resolution :: Text -> Type v loc -> loc -> [Suggestion v loc] -> Resolution v loc
[resolvedName] :: Resolution v loc -> Text
[inferredType] :: Resolution v loc -> Type v loc
[resolvedLoc] :: Resolution v loc -> loc
[suggestions] :: Resolution v loc -> [Suggestion v loc]

-- | Infer the type of a <a>Term</a>, using type-directed name resolution
--   to attempt to resolve unknown symbols.
synthesizeAndResolve :: (Monad f, Var v, Monoid loc, Ord loc) => Env v loc -> TDNR f v loc (Type v loc)
compilerBug :: CompilerBug v loc -> Result (Notes v loc) ()
typeError :: ErrorNote v loc -> Result (Notes v loc) ()
btw :: Monad f => InfoNote v loc -> ResultT (Notes v loc) f ()
liftResult :: Monad f => Result (Notes v loc) a -> TDNR f v loc a
typeDirectedNameResolution :: forall v loc f. (Monad f, Var v, Ord loc, Monoid loc) => Notes v loc -> Type v loc -> Env v loc -> TDNR f v loc (Type v loc)

-- | Check whether a term matches a type, using a function to resolve the
--   type of <tt>Ref</tt> constructors contained in the term. Returns
--   <tt>typ</tt> if successful, and a note about typechecking failure
--   otherwise.
check :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> Type v loc -> ResultT (Notes v loc) f (Type v loc)

-- | <tt>checkAdmissible</tt> e t` tests that `(f : t -&gt; r) e` is
--   well-typed. If <tt>t</tt> has quantifiers, these are moved outside, so
--   if `t : forall a . a`, this will check that `(f : forall a . a -&gt;
--   a) e` is well typed. checkAdmissible' :: Var v =&gt; Term v -&gt; Type
--   v -&gt; Either Note (Type v) checkAdmissible' term typ = synthesize'
--   (Term.blank() <a>ann_</a> tweak typ <a>app_</a> term) where tweak
--   (Type.ForallNamed' v body) = Type.forall() v (tweak body) tweak t =
--   Type.arrow() t t | Returns <a>True</a> if the expression is
--   well-typed, <a>False</a> otherwise
wellTyped :: (Monad f, Var v, Ord loc) => Env v loc -> Term v loc -> f Bool
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.NamedReference v loc)
instance GHC.Base.Semigroup (Unison.Typechecker.Notes v loc)
instance GHC.Base.Monoid (Unison.Typechecker.Notes v loc)

module Unison.Codebase.TermEdit.Typing
typing :: Var v => Type v loc -> Type v loc -> Typing


-- | Find a computation of type '{IO} () in the codebase.
module Unison.Codebase.MainTerm
data MainTerm v
NotAFunctionName :: String -> MainTerm v
NotFound :: String -> MainTerm v
BadType :: String -> Maybe (Type v Ann) -> MainTerm v
Success :: HashQualified Name -> Term v Ann -> Type v Ann -> MainTerm v
getMainTerm :: (Monad m, Var v) => (Reference -> m (Maybe (Type v Ann))) -> Names -> String -> Type v Ann -> m (MainTerm v)
builtinMain :: Var v => a -> Type v a
resultArr :: Ord v => a -> Type v a
builtinResultArr :: Ord v => a -> Type v a
builtinTest :: Ord v => a -> Type v a


-- | Execute a computation of type '{IO} () that has been previously added
--   to the codebase, without setting up an interactive environment.
--   
--   This allows one to run standalone applications implemented in the
--   Unison language.
module Unison.Codebase.Execute
execute :: Codebase IO Symbol Ann -> Runtime Symbol -> String -> IO ()

module Unison.TermPrinter
type SyntaxText = SyntaxText' Reference
pretty :: Var v => PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock' :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty SyntaxText
pretty' :: Var v => Maybe Width -> PrettyPrintEnv -> Term v a -> ColorText
data AmbientContext
AmbientContext :: Int -> BlockContext -> InfixContext -> Imports -> DocLiteralContext -> Bool -> AmbientContext
[precedence] :: AmbientContext -> Int
[blockContext] :: AmbientContext -> BlockContext
[infixContext] :: AmbientContext -> InfixContext
[imports] :: AmbientContext -> Imports
[docContext] :: AmbientContext -> DocLiteralContext
[elideUnit] :: AmbientContext -> Bool
data BlockContext
Block :: BlockContext
Normal :: BlockContext
data InfixContext
Infix :: InfixContext
NonInfix :: InfixContext
data DocLiteralContext
NoDoc :: DocLiteralContext
MaybeDoc :: DocLiteralContext
pretty0 :: forall v. Var v => PrettyPrintEnv -> AmbientContext -> Term3 v PrintAnnotation -> Pretty SyntaxText
prettyPattern :: forall v loc. Var v => PrettyPrintEnv -> AmbientContext -> Int -> [v] -> Pattern loc -> (Pretty SyntaxText, [v])
type MatchCase' ann tm = ([Pattern ann], Maybe tm, tm)
arity1Branches :: [MatchCase ann tm] -> [MatchCase' ann tm]
groupCases :: Ord v => [MatchCase' () (Term3 v ann)] -> [([Pattern ()], [v], [(Maybe (Term3 v ann), Term3 v ann)])]
printCase :: Var v => PrettyPrintEnv -> Imports -> DocLiteralContext -> [MatchCase' () (Term3 v PrintAnnotation)] -> Pretty SyntaxText
prettyBinding :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
prettyBinding' :: Var v => Width -> PrettyPrintEnv -> HashQualified Name -> Term v a -> ColorText
prettyBinding0 :: Var v => PrettyPrintEnv -> AmbientContext -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
isDocLiteral :: Term3 v PrintAnnotation -> Bool
prettyDoc :: Var v => PrettyPrintEnv -> Imports -> Term3 v a -> Pretty SyntaxText
paren :: Bool -> Pretty SyntaxText -> Pretty SyntaxText
parenIfInfix :: HashQualified Name -> InfixContext -> Pretty SyntaxText -> Pretty SyntaxText
l :: IsString s => String -> Pretty s
isSymbolic :: HashQualified Name -> Bool
isSymbolic' :: Name -> Bool
isBlank :: String -> Bool
emptyAc :: AmbientContext
emptyBlockAc :: AmbientContext
ac :: Int -> BlockContext -> Imports -> DocLiteralContext -> AmbientContext
fmt :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)
data PrintAnnotation
PrintAnnotation :: Map Suffix (Map Prefix Int) -> PrintAnnotation
[usages] :: PrintAnnotation -> Map Suffix (Map Prefix Int)
suffixCounterTerm :: Var v => PrettyPrintEnv -> Term2 v at ap v a -> PrintAnnotation
suffixCounterType :: Var v => PrettyPrintEnv -> Type v a -> PrintAnnotation
printAnnotate :: (Var v, Ord v) => PrettyPrintEnv -> Term2 v at ap v a -> Term3 v PrintAnnotation
countTypeUsages :: (Var v, Ord v) => PrettyPrintEnv -> Type v a -> PrintAnnotation
countPatternUsages :: PrettyPrintEnv -> Pattern loc -> PrintAnnotation
countHQ :: HashQualified Name -> PrintAnnotation
countName :: Name -> PrintAnnotation
joinName :: Prefix -> Suffix -> Name
dotConcat :: [Text] -> Text
noImportRefs :: Reference -> Bool
(|>) :: a -> (a -> b) -> b
infixl 0 |>
calcImports :: (Var v, Ord v) => Imports -> Term3 v PrintAnnotation -> (Imports, [Pretty SyntaxText] -> Pretty SyntaxText)
allInSubBlock :: (Var v, Ord v) => Term3 v PrintAnnotation -> Prefix -> Suffix -> Int -> Bool
immediateChildBlockTerms :: (Var vt, Var v) => Term2 vt at ap v a -> [Term2 vt at ap v a]
isDestructuringBind :: Ord v => Term f v a -> [MatchCase loc (Term f v a)] -> Bool
isBlock :: Ord v => Term2 vt at ap v a -> Bool
pattern LetBlock :: Ord v => [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
unLetBlock :: Ord v => Term2 vt at ap v a -> Maybe ([(v, Term2 vt at ap v a)], Term2 vt at ap v a)
pattern LamsNamedMatch' :: forall v vt at ap a. Var v => [v] -> [([Pattern ap], Maybe (Term2 vt at ap v a), Term2 vt at ap v a)] -> Term2 vt at ap v a
unLamsMatch' :: Var v => Term2 vt at ap v a -> Maybe ([v], [([Pattern ap], Maybe (Term2 vt at ap v a), Term2 vt at ap v a)])
pattern Bytes' :: [Word64] -> Term3 v PrintAnnotation
toBytes :: Term3 v PrintAnnotation -> Maybe [Word64]
prettyDoc2 :: forall v. Var v => PrettyPrintEnv -> AmbientContext -> Term3 v PrintAnnotation -> Maybe (Pretty SyntaxText)
toDocJoin :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Term3 v PrintAnnotation]
toDocUntitledSection :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Term3 v PrintAnnotation]
toDocColumn :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Term3 v PrintAnnotation]
toDocGroup :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocWord :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe Text
toDocBold :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocCode :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocCodeBlock :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Text, Text)
toDocVerbatim :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe Text
toDocEval :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
_oldDocEval :: Reference
_oldDocEvalInline :: Reference
toDocEvalInline :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocExample :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocExampleBlock :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocExample' :: Ord v => Text -> PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocTransclude :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocLink :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Either Reference Referent)
toDocNamedLink :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation, Term3 v PrintAnnotation)
toDocItalic :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocStrikethrough :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocParagraph :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Term3 v PrintAnnotation]
toDocEmbedTermLink :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe Referent
toDocEmbedTypeLink :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe Reference
toDocSourceAnnotations :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Referent]
toDocSourceElement :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Either Reference Referent, [Referent])
toDocSource' :: Ord v => Text -> PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [(Either Reference Referent, [Referent])]
toDocSource :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [(Either Reference Referent, [Referent])]
toDocFoldedSource :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [(Either Reference Referent, [Referent])]
toDocSignatureInline :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe Referent
toDocEmbedSignatureLink :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe Referent
toDocEmbedAnnotation :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation)
toDocEmbedAnnotations :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Term3 v PrintAnnotation]
toDocSignature :: Ord v => PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Referent]
toDocBulletedList :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe [Term3 v PrintAnnotation]
toDocNumberedList :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Word64, [Term3 v PrintAnnotation])
toDocSection :: PrettyPrintEnv -> Term3 v PrintAnnotation -> Maybe (Term3 v PrintAnnotation, [Term3 v PrintAnnotation])
nameEndsWith :: PrettyPrintEnv -> Text -> Reference -> Bool
instance GHC.Show.Show Unison.TermPrinter.BlockContext
instance GHC.Classes.Eq Unison.TermPrinter.BlockContext
instance GHC.Show.Show Unison.TermPrinter.InfixContext
instance GHC.Classes.Eq Unison.TermPrinter.InfixContext
instance GHC.Show.Show Unison.TermPrinter.DocLiteralContext
instance GHC.Classes.Eq Unison.TermPrinter.DocLiteralContext
instance GHC.Show.Show Unison.TermPrinter.PrintAnnotation
instance GHC.Base.Semigroup Unison.TermPrinter.PrintAnnotation
instance GHC.Base.Monoid Unison.TermPrinter.PrintAnnotation

module Unison.PrintError
type Env = PrettyPrintEnv
pattern Code :: Color
pattern Type1 :: Color
pattern Type2 :: Color
pattern ErrorSite :: Color
pattern TypeKeyword :: Color
pattern AbilityKeyword :: Color
pattern Identifier :: Color
defaultWidth :: Width
structuralVsUniqueDocsLink :: IsString a => Pretty a
fromOverHere' :: Ord a => String -> [Maybe (Range, a)] -> [Maybe (Range, a)] -> Pretty (AnnotatedText a)
fromOverHere :: Ord a => String -> [(Range, a)] -> [(Range, a)] -> Pretty (AnnotatedText a)
showTypeWithProvenance :: (Var v, Annotated a, Ord style) => Env -> String -> style -> Type v a -> Pretty (AnnotatedText style)
styleAnnotated :: Annotated a => sty -> a -> Maybe (Range, sty)
style :: s -> String -> Pretty (AnnotatedText s)
stylePretty :: Color -> Pretty ColorText -> Pretty ColorText
describeStyle :: Color -> Pretty ColorText
renderTypeInfo :: forall v loc sty. (Var v, Annotated loc, Ord loc, Show loc) => TypeInfo v loc -> Env -> Pretty (AnnotatedText sty)
renderTypeError :: forall v loc. (Var v, Annotated loc, Ord loc, Show loc) => TypeError v loc -> Env -> String -> Pretty ColorText
renderCompilerBug :: (Var v, Annotated loc, Ord loc, Show loc) => Env -> String -> CompilerBug v loc -> Pretty ColorText
renderContext :: (Var v, Ord loc) => Env -> Context v loc -> Pretty (AnnotatedText a)
renderTerm :: (IsString s, Var v) => Env -> Term v loc -> s

-- | renders a type with no special styling
renderType' :: (IsString s, Var v) => Env -> Type v loc -> s

-- | <a>f</a> may do some styling based on <tt>loc</tt>. | You can pass
--   `(const id)` if no styling is needed, or call <a>renderType</a>`.
renderType :: Var v => Env -> (loc -> Pretty (AnnotatedText a) -> Pretty (AnnotatedText a)) -> Type v loc -> Pretty (AnnotatedText a)
renderSuggestion :: (IsString s, Semigroup s, Var v) => Env -> Suggestion v loc -> s
spaces :: (IsString a, Monoid a) => (b -> a) -> [b] -> a
arrows :: (IsString a, Monoid a) => (b -> a) -> [b] -> a
commas :: (IsString a, Monoid a) => (b -> a) -> [b] -> a
renderVar :: (IsString a, Var v) => v -> a
renderVar' :: (Var v, Annotated a) => Env -> Context v a -> v -> String
prettyVar :: Var v => v -> Pretty ColorText
renderKind :: Kind -> Pretty (AnnotatedText a)
showTermRef :: IsString s => Env -> Referent -> s
showTypeRef :: IsString s => Env -> Reference -> s
showConstructor :: IsString s => Env -> ConstructorReference -> s
styleInOverallType :: (Var v, Annotated a, Eq a) => Env -> Type v a -> Type v a -> Color -> Pretty ColorText
_posToEnglish :: IsString s => Pos -> s
rangeForToken :: Token a -> Range
rangeToEnglish :: IsString s => Range -> s
annotatedToEnglish :: (Annotated a, IsString s) => a -> s
rangeForAnnotated :: Annotated a => a -> Maybe Range
showLexerOutput :: Bool
renderNoteAsANSI :: (Var v, Annotated a, Show a, Ord a) => Width -> Env -> String -> Note v a -> String
renderParseErrorAsANSI :: Var v => Width -> String -> Err v -> String
printNoteWithSource :: (Var v, Annotated a, Show a, Ord a) => Env -> String -> Note v a -> Pretty ColorText
_printPosRange :: String -> Pos -> Pos -> String
_printArrowsAtPos :: String -> Int -> Int -> String
pattern LexerError :: [Token Lexeme] -> Err -> Maybe (ErrorItem (Token Lexeme))
firstLexerError :: Foldable t => t (Token Lexeme) -> Maybe ([Token Lexeme], Err)
prettyParseError :: forall v. Var v => String -> Err v -> Pretty ColorText
annotatedAsErrorSite :: Annotated a => String -> a -> Pretty ColorText
annotatedAsStyle :: (Ord style, Annotated a) => style -> String -> a -> Pretty (AnnotatedText style)
annotatedsAsErrorSite :: Annotated a => String -> [a] -> Pretty ColorText
annotatedsAsStyle :: Annotated a => Color -> String -> [a] -> Pretty ColorText
annotatedsStartingLineAsStyle :: Annotated a => Color -> String -> [a] -> Pretty ColorText
tokenAsErrorSite :: String -> Token a -> Pretty ColorText
tokensAsErrorSite :: String -> [Token a] -> Pretty ColorText
showSourceMaybes :: Ord a => String -> [Maybe (Range, a)] -> Pretty (AnnotatedText a)
showSource :: Ord a => String -> [(Range, a)] -> Pretty (AnnotatedText a)
showSource1 :: Ord a => String -> (Range, a) -> Pretty (AnnotatedText a)
findTerm :: Seq (PathElement v loc) -> Maybe loc
prettyTypecheckError :: (Var v, Ord loc, Show loc, Annotated loc) => ErrorNote v loc -> Env -> String -> Pretty ColorText
prettyTypeInfo :: (Var v, Ord loc, Show loc, Annotated loc) => InfoNote v loc -> Env -> Pretty ColorText
intLiteralSyntaxTip :: Term v loc -> Type v loc -> Pretty ColorText

-- | Pretty prints resolution failure annotations, including a table of
--   disambiguation suggestions.
prettyResolutionFailures :: forall v a. (Annotated a, Var v, Ord a) => String -> [ResolutionFailure v a] -> Pretty ColorText
useExamples :: Pretty ColorText

module Unison.Parsers
unsafeGetRightFrom :: (Var v, Show v) => String -> Either (Err v) a -> a
parse :: Var v => P v a -> String -> ParsingEnv -> Either (Err v) a
parseTerm :: Var v => String -> ParsingEnv -> Either (Err v) (Term v Ann)
parseType :: Var v => String -> ParsingEnv -> Either (Err v) (Type v Ann)
parseFile :: Var v => FilePath -> String -> ParsingEnv -> Either (Err v) (UnisonFile v Ann)
readAndParseFile :: Var v => ParsingEnv -> FilePath -> IO (Either (Err v) (UnisonFile v Ann))
unsafeParseTerm :: Var v => String -> ParsingEnv -> Term v Ann
unsafeReadAndParseFile :: ParsingEnv -> FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFileBuiltinsOnly :: FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFile :: String -> ParsingEnv -> UnisonFile Symbol Ann

module Unison.FileParsers
type Term v = Term v Ann
type Type v = Type v Ann
type UnisonFile v = UnisonFile v Ann
type Result' v = Result (Seq (Note v Ann))
debug :: Bool
convertNotes :: Ord v => Notes v ann -> Seq (Note v ann)
parseAndSynthesizeFile :: (Var v, Monad m) => [Type v] -> (Set Reference -> m (TypeLookup v Ann)) -> ParsingEnv -> FilePath -> Text -> ResultT (Seq (Note v Ann)) m (Either Names (TypecheckedUnisonFile v Ann))
type TDNRMap v = Map Name [NamedReference v Ann]
resolveNames :: (Var v, Monad m) => (Set Reference -> m (TypeLookup v Ann)) -> Names -> UnisonFile v -> ResultT (Seq (Note v Ann)) m (Term v, TDNRMap v, TypeLookup v Ann)
synthesizeFile' :: forall v. Var v => [Type v] -> TypeLookup v Ann -> UnisonFile v -> Result (Seq (Note v Ann)) (TypecheckedUnisonFile v Ann)
synthesizeFile :: forall v. Var v => [Type v] -> TypeLookup v Ann -> TDNRMap v -> UnisonFile v -> Term v -> Result (Seq (Note v Ann)) (TypecheckedUnisonFile v Ann)

module Unison.Runtime.IOSource
debug :: Bool
typecheckedFile :: TypecheckedUnisonFile Symbol Ann
typecheckedFile' :: TypecheckedUnisonFile Symbol Ann
typecheckedFileTerms :: Map Symbol Reference
termNamed :: String -> Reference
codeLookup :: CodeLookup Symbol Identity Ann
typeNamedId :: String -> Id
typeNamed :: String -> Reference
abilityNamedId :: String -> Id
eitherReference :: Reference
optionReference :: Reference
isTestReference :: Reference
isPropagatedReference :: Reference
isTest :: (Reference, Reference)
isIOTest :: (Reference, Reference)
isPropagatedValue :: Reference
eitherLeftId :: ConstructorId
eitherRightId :: ConstructorId
someId :: ConstructorId
noneId :: ConstructorId
doc2Ref :: Reference
doc2SpecialFormRef :: Reference
doc2TermRef :: Reference
prettyRef :: Reference
prettyAnnotatedRef :: Reference
ansiColorRef :: Reference
consoleTextRef :: Reference
pattern Doc2Ref :: Reference
doc2WordId :: ConstructorId
doc2CodeId :: ConstructorId
doc2CodeBlockId :: ConstructorId
doc2BoldId :: ConstructorId
doc2ItalicId :: ConstructorId
doc2StrikethroughId :: ConstructorId
doc2StyleId :: ConstructorId
doc2AnchorId :: ConstructorId
doc2BlockquoteId :: ConstructorId
doc2BlanklineId :: ConstructorId
doc2LinebreakId :: ConstructorId
doc2SectionBreakId :: ConstructorId
doc2TooltipId :: ConstructorId
doc2AsideId :: ConstructorId
doc2CalloutId :: ConstructorId
doc2TableId :: ConstructorId
doc2FoldedId :: ConstructorId
doc2ParagraphId :: ConstructorId
doc2BulletedListId :: ConstructorId
doc2NumberedListId :: ConstructorId
doc2SectionId :: ConstructorId
doc2NamedLinkId :: ConstructorId
doc2ImageId :: ConstructorId
doc2SpecialId :: ConstructorId
doc2JoinId :: ConstructorId
doc2UntitledSectionId :: ConstructorId
doc2ColumnId :: ConstructorId
doc2GroupId :: ConstructorId
pattern Doc2Word :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Code :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2CodeBlock :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Bold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Italic :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Strikethrough :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Style :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Anchor :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Blockquote :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Blankline :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Linebreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SectionBreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Tooltip :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Aside :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Callout :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Table :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Folded :: Bool -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Paragraph :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2BulletedList :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2NumberedList :: Word64 -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Section :: Term2 typeVar typeAnn patternAnn v a -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2NamedLink :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Image :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Special :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Join :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2UntitledSection :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Column :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Group :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormRef :: Reference
doc2SpecialFormSourceId :: ConstructorId
doc2SpecialFormFoldedSourceId :: ConstructorId
doc2SpecialFormExampleId :: ConstructorId
doc2SpecialFormExampleBlockId :: ConstructorId
doc2SpecialFormLinkId :: ConstructorId
doc2SpecialFormSignatureId :: ConstructorId
doc2SpecialFormSignatureInlineId :: ConstructorId
doc2SpecialFormEvalId :: ConstructorId
doc2SpecialFormEvalInlineId :: ConstructorId
doc2SpecialFormEmbedId :: ConstructorId
doc2SpecialFormEmbedInlineId :: ConstructorId
pattern Doc2SpecialFormSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormFoldedSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormExample :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormExampleBlock :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignatureInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEval :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEvalInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbed :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Example :: forall vt at ap v a. [v] -> Term2 vt at ap v a -> Term (F vt at ap) v a
pattern Doc2Term :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2TermRef :: Reference
pattern PrettyAnnotatedRef :: Reference
prettyEmptyId :: ConstructorId
prettyGroupId :: ConstructorId
prettyLitId :: ConstructorId
prettyWrapId :: ConstructorId
prettyOrElseId :: ConstructorId
prettyIndentId :: ConstructorId
prettyAppendId :: ConstructorId
prettyTableId :: ConstructorId
pattern PrettyEmpty :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern PrettyGroup :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyLit :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyWrap :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyIndent :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyOrElse :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyTable :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyAppend :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyRef :: Reference
prettyGetRef :: Reference
doc2FormatConsoleRef :: Reference
pattern AnsiColorRef :: Reference
ansiColorBlackId :: ConstructorId
pattern AnsiColorBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextRef :: Reference
consoleTextPlainId :: ConstructorId
consoleTextForegroundId :: ConstructorId
consoleTextBackgroundId :: ConstructorId
consoleTextBoldId :: ConstructorId
consoleTextUnderlineId :: ConstructorId
consoleTextInvertId :: ConstructorId
pattern ConsoleTextPlain :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextForeground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBackground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextUnderline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextInvert :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
constructorNamed :: Reference -> Text -> ConstructorId
constructorName :: Reference -> ConstructorId -> Text
source :: Text

module Unison.Codebase.BranchDiff
data DiffType a
Create :: a -> DiffType a
Delete :: a -> DiffType a
Modify :: a -> DiffType a
data NamespaceSlice r
NamespaceSlice :: Relation r Name -> Relation3 r Name Value -> NamespaceSlice r
[names] :: NamespaceSlice r -> Relation r Name
[metadata] :: NamespaceSlice r -> Relation3 r Name Value
data DiffSlice r
DiffSlice :: Map Name (Set r, Set r) -> Relation r Name -> Relation r Name -> Map r (Set Name, Set Name) -> Relation3 r Name Value -> Relation3 r Name Value -> DiffSlice r
[tallnamespaceUpdates] :: DiffSlice r -> Map Name (Set r, Set r)
[talladds] :: DiffSlice r -> Relation r Name
[tallremoves] :: DiffSlice r -> Relation r Name
[trenames] :: DiffSlice r -> Map r (Set Name, Set Name)
[taddedMetadata] :: DiffSlice r -> Relation3 r Name Value
[tremovedMetadata] :: DiffSlice r -> Relation3 r Name Value
data BranchDiff
BranchDiff :: DiffSlice Referent -> DiffSlice Reference -> Map Name (DiffType PatchDiff) -> BranchDiff
[termsDiff] :: BranchDiff -> DiffSlice Referent
[typesDiff] :: BranchDiff -> DiffSlice Reference
[patchesDiff] :: BranchDiff -> Map Name (DiffType PatchDiff)
diff0 :: forall m. Monad m => Branch0 m -> Branch0 m -> m BranchDiff
patchDiff :: forall m. Monad m => Branch0 m -> Branch0 m -> m (Map Name (DiffType PatchDiff))
deepr4ToSlice :: Ord r => Relation r Name -> R4 r Name -> NamespaceSlice r
computeSlices :: NamespaceSlice Referent -> NamespaceSlice Referent -> NamespaceSlice Reference -> NamespaceSlice Reference -> (DiffSlice Referent, DiffSlice Reference)
namespaceUpdates :: Ord r => DiffSlice r -> Map Name (Set r, Set r)
propagatedUpdates :: Ord r => DiffSlice r -> Map Name (Set r)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffType a)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Codebase.BranchDiff.NamespaceSlice r)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Show.Show Unison.Codebase.BranchDiff.BranchDiff

module Unison.DeclPrinter
prettyDecl :: Var v => PrettyPrintEnvDecl -> Reference -> HashQualified Name -> Decl v a -> Pretty SyntaxText
prettyDeclHeader :: Var v => HashQualified Name -> Either (EffectDeclaration v a) (DataDeclaration v a) -> Pretty SyntaxText
prettyDeclOrBuiltinHeader :: Var v => HashQualified Name -> DeclOrBuiltin v a -> Pretty SyntaxText

module Unison.Server.Doc
type Nat = Word64
type SSyntaxText = SyntaxText' Reference
data Doc
Word :: Text -> Doc
Code :: Doc -> Doc
CodeBlock :: Text -> Doc -> Doc
Bold :: Doc -> Doc
Italic :: Doc -> Doc
Strikethrough :: Doc -> Doc
Style :: Text -> Doc -> Doc
Anchor :: Text -> Doc -> Doc
Blockquote :: Doc -> Doc
Blankline :: Doc
Linebreak :: Doc
SectionBreak :: Doc
Tooltip :: Doc -> Doc -> Doc
Aside :: Doc -> Doc
Callout :: Maybe Doc -> Doc -> Doc
Table :: [[Doc]] -> Doc
Folded :: Bool -> Doc -> Doc -> Doc
Paragraph :: [Doc] -> Doc
BulletedList :: [Doc] -> Doc
NumberedList :: Nat -> [Doc] -> Doc
Section :: Doc -> [Doc] -> Doc
NamedLink :: Doc -> Doc -> Doc
Image :: Doc -> Doc -> Maybe Doc -> Doc
Special :: SpecialForm -> Doc
Join :: [Doc] -> Doc
UntitledSection :: [Doc] -> Doc
Column :: [Doc] -> Doc
Group :: Doc -> Doc
type UnisonHash = Text
data Ref a
Term :: a -> Ref a
Type :: a -> Ref a
data SpecialForm
Source :: [Ref (UnisonHash, DisplayObject SyntaxText Src)] -> SpecialForm
FoldedSource :: [Ref (UnisonHash, DisplayObject SyntaxText Src)] -> SpecialForm
Example :: SyntaxText -> SpecialForm
ExampleBlock :: SyntaxText -> SpecialForm
Link :: SyntaxText -> SpecialForm
Signature :: [SyntaxText] -> SpecialForm
SignatureInline :: SyntaxText -> SpecialForm
Eval :: SyntaxText -> SyntaxText -> SpecialForm
EvalInline :: SyntaxText -> SyntaxText -> SpecialForm
Embed :: SyntaxText -> SpecialForm
EmbedInline :: SyntaxText -> SpecialForm
data Src
Src :: SyntaxText -> SyntaxText -> Src
renderDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Doc
instance Data.Traversable.Traversable Unison.Server.Doc.Ref
instance Data.Foldable.Foldable Unison.Server.Doc.Ref
instance GHC.Base.Functor Unison.Server.Doc.Ref
instance GHC.Generics.Generic (Unison.Server.Doc.Ref a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Server.Doc.Ref a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Server.Doc.Ref a)
instance GHC.Generics.Generic Unison.Server.Doc.Src
instance GHC.Show.Show Unison.Server.Doc.Src
instance GHC.Classes.Eq Unison.Server.Doc.Src
instance GHC.Generics.Generic Unison.Server.Doc.SpecialForm
instance GHC.Show.Show Unison.Server.Doc.SpecialForm
instance GHC.Classes.Eq Unison.Server.Doc.SpecialForm
instance GHC.Generics.Generic Unison.Server.Doc.Doc
instance GHC.Show.Show Unison.Server.Doc.Doc
instance GHC.Classes.Eq Unison.Server.Doc.Doc

module Unison.Server.Types
type APIHeaders x = Headers '[Header "Access-Control-Allow-Origin" String, Header "Cache-Control" String] x
type APIGet c = Get '[JSON] (APIHeaders c)
type HashQualifiedName = Text
type NamespaceFQN = Text
type Size = Int
type UnisonName = Text
type UnisonHash = Text
newtype Suffixify
Suffixify :: Bool -> Suffixify
[suffixified] :: Suffixify -> Bool
data TermDefinition
TermDefinition :: [HashQualifiedName] -> HashQualifiedName -> Maybe TermTag -> DisplayObject SyntaxText SyntaxText -> SyntaxText -> [(HashQualifiedName, UnisonHash, Doc)] -> TermDefinition
[termNames] :: TermDefinition -> [HashQualifiedName]
[bestTermName] :: TermDefinition -> HashQualifiedName
[defnTermTag] :: TermDefinition -> Maybe TermTag
[termDefinition] :: TermDefinition -> DisplayObject SyntaxText SyntaxText
[signature] :: TermDefinition -> SyntaxText
[termDocs] :: TermDefinition -> [(HashQualifiedName, UnisonHash, Doc)]
data TypeDefinition
TypeDefinition :: [HashQualifiedName] -> HashQualifiedName -> Maybe TypeTag -> DisplayObject SyntaxText SyntaxText -> [(HashQualifiedName, UnisonHash, Doc)] -> TypeDefinition
[typeNames] :: TypeDefinition -> [HashQualifiedName]
[bestTypeName] :: TypeDefinition -> HashQualifiedName
[defnTypeTag] :: TypeDefinition -> Maybe TypeTag
[typeDefinition] :: TypeDefinition -> DisplayObject SyntaxText SyntaxText
[typeDocs] :: TypeDefinition -> [(HashQualifiedName, UnisonHash, Doc)]
data DefinitionDisplayResults
DefinitionDisplayResults :: Map UnisonHash TermDefinition -> Map UnisonHash TypeDefinition -> [HashQualifiedName] -> DefinitionDisplayResults
[termDefinitions] :: DefinitionDisplayResults -> Map UnisonHash TermDefinition
[typeDefinitions] :: DefinitionDisplayResults -> Map UnisonHash TypeDefinition
[missingDefinitions] :: DefinitionDisplayResults -> [HashQualifiedName]
data TermTag
Doc :: TermTag
Test :: TermTag
data TypeTag
Ability :: TypeTag
Data :: TypeTag
data UnisonRef
TypeRef :: UnisonHash -> UnisonRef
TermRef :: UnisonHash -> UnisonRef
data FoundEntry
FoundTerm :: NamedTerm -> FoundEntry
FoundType :: NamedType -> FoundEntry
unisonRefToText :: UnisonRef -> Text
data NamedTerm
NamedTerm :: HashQualifiedName -> UnisonHash -> Maybe SyntaxText -> Maybe TermTag -> NamedTerm
[termName] :: NamedTerm -> HashQualifiedName
[termHash] :: NamedTerm -> UnisonHash
[termType] :: NamedTerm -> Maybe SyntaxText
[termTag] :: NamedTerm -> Maybe TermTag
data NamedType
NamedType :: HashQualifiedName -> UnisonHash -> TypeTag -> NamedType
[typeName] :: NamedType -> HashQualifiedName
[typeHash] :: NamedType -> UnisonHash
[typeTag] :: NamedType -> TypeTag
munge :: Text -> ByteString
mungeShow :: Show s => s -> ByteString
mungeString :: String -> ByteString
defaultWidth :: Width
discard :: Applicative m => a -> m ()
mayDefaultWidth :: Maybe Width -> Width
addHeaders :: v -> APIHeaders v
branchToUnisonHash :: Branch m -> UnisonHash
instance GHC.Generics.Generic Unison.Server.Types.Suffixify
instance GHC.Show.Show Unison.Server.Types.Suffixify
instance GHC.Classes.Ord Unison.Server.Types.Suffixify
instance GHC.Classes.Eq Unison.Server.Types.Suffixify
instance GHC.Generics.Generic Unison.Server.Types.TermTag
instance GHC.Show.Show Unison.Server.Types.TermTag
instance GHC.Classes.Ord Unison.Server.Types.TermTag
instance GHC.Classes.Eq Unison.Server.Types.TermTag
instance GHC.Generics.Generic Unison.Server.Types.TermDefinition
instance GHC.Show.Show Unison.Server.Types.TermDefinition
instance GHC.Classes.Eq Unison.Server.Types.TermDefinition
instance GHC.Generics.Generic Unison.Server.Types.TypeTag
instance GHC.Show.Show Unison.Server.Types.TypeTag
instance GHC.Classes.Ord Unison.Server.Types.TypeTag
instance GHC.Classes.Eq Unison.Server.Types.TypeTag
instance GHC.Generics.Generic Unison.Server.Types.TypeDefinition
instance GHC.Show.Show Unison.Server.Types.TypeDefinition
instance GHC.Classes.Eq Unison.Server.Types.TypeDefinition
instance GHC.Generics.Generic Unison.Server.Types.DefinitionDisplayResults
instance GHC.Show.Show Unison.Server.Types.DefinitionDisplayResults
instance GHC.Classes.Eq Unison.Server.Types.DefinitionDisplayResults
instance GHC.Generics.Generic Unison.Server.Types.UnisonRef
instance GHC.Show.Show Unison.Server.Types.UnisonRef
instance GHC.Classes.Ord Unison.Server.Types.UnisonRef
instance GHC.Classes.Eq Unison.Server.Types.UnisonRef
instance GHC.Show.Show Unison.Server.Types.NamedTerm
instance GHC.Generics.Generic Unison.Server.Types.NamedTerm
instance GHC.Classes.Eq Unison.Server.Types.NamedTerm
instance GHC.Show.Show Unison.Server.Types.NamedType
instance GHC.Generics.Generic Unison.Server.Types.NamedType
instance GHC.Classes.Eq Unison.Server.Types.NamedType
instance GHC.Generics.Generic Unison.Server.Types.FoundEntry
instance GHC.Show.Show Unison.Server.Types.FoundEntry
instance GHC.Classes.Eq Unison.Server.Types.FoundEntry
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Server.Types.Suffixify
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Server.Types.Suffixify
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.ShortBranchHash.ShortBranchHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Util.Pretty.Width
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Util.Pretty.Width
instance (Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema a) => Data.OpenApi.Internal.Schema.ToSchema (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.ShortHash.ShortHash
instance Data.OpenApi.Internal.Schema.ToSchema n => Data.OpenApi.Internal.Schema.ToSchema (Unison.HashQualified.HashQualified n)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.ConstructorType.ConstructorType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeDefinition
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermDefinition
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.DefinitionDisplayResults
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.FoundEntry
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamedTerm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamedType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermTag
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeTag
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.FoundEntry
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamedType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamedTerm
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.DefinitionDisplayResults
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeTag
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermTag
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Name.Name
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Name.Name
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.ShortBranchHash.ShortBranchHash
instance (Data.Aeson.Types.ToJSON.ToJSON b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.ShortHash.ShortHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.ShortHash.ShortHash
instance Data.Aeson.Types.ToJSON.ToJSON n => Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified.HashQualified n)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.ConstructorType.ConstructorType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.Doc
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.SpecialForm
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.Src
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.Ref a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.Doc
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.SpecialForm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.Src
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.Ref a)


-- | Render Unison.Server.Doc and embedded source to Html
module Unison.Server.Doc.AsHtml
data NamedLinkHref
Href :: Text -> NamedLinkHref
DocLinkHref :: Name -> NamedLinkHref
ReferenceHref :: Text -> NamedLinkHref
InvalidHref :: NamedLinkHref
data EmbeddedSource
EmbeddedSource :: SyntaxText -> SyntaxText -> EmbeddedSource
Builtin :: SyntaxText -> EmbeddedSource
embeddedSource :: Ref (UnisonHash, DisplayObject SyntaxText Src) -> Maybe EmbeddedSource
inlineCode :: [Text] -> Html () -> Html ()
codeBlock :: [Attribute] -> Html () -> Html ()
normalizeHref :: Map Referent Name -> Doc -> NamedLinkHref
data IsFolded
IsFolded :: Bool -> [Html ()] -> [Html ()] -> IsFolded
Disabled :: Html () -> IsFolded
foldedToHtml :: [Attribute] -> IsFolded -> Html ()
foldedToHtmlSource :: Bool -> EmbeddedSource -> Html ()

-- | Merge adjacent Word elements in a list to 1 element with a string of
--   words separated by spaceâ€” useful for rendering to the dom without
--   creating dom elements for each and every word in the doc, but instead
--   rely on textNodes
mergeWords :: Text -> [Doc] -> [Doc]

-- | Merge down Doc to Text by merging Paragraphs and Words. Used for
--   things like extract an src of an image. I.e something that has to be a
--   Text and not a Doc
toText :: Text -> Doc -> Text
toHtml :: Map Referent Name -> Doc -> Html ()

-- | Unison Doc allows endlessly deep section nesting with titles, but HTML
--   only supports to h1-h6, so we clamp the sectionLevel when converting
h :: Nat -> Html () -> Html ()
badge :: Html () -> Html ()
textToClass :: Text -> Text

module Unison.Server.Backend
type SyntaxText = SyntaxText' Reference
data ShallowListEntry v a
ShallowTermEntry :: TermEntry v a -> ShallowListEntry v a
ShallowTypeEntry :: TypeEntry -> ShallowListEntry v a
ShallowBranchEntry :: NameSegment -> ShortBranchHash -> Int -> ShallowListEntry v a
ShallowPatchEntry :: NameSegment -> ShallowListEntry v a
listEntryName :: ShallowListEntry v a -> Text
data BackendError
NoSuchNamespace :: Absolute -> BackendError
BadRootBranch :: GetRootBranchError -> BackendError
CouldntExpandBranchHash :: ShortBranchHash -> BackendError
AmbiguousBranchHash :: ShortBranchHash -> Set ShortBranchHash -> BackendError
NoBranchForHash :: Hash -> BackendError
CouldntLoadBranch :: Hash -> BackendError
MissingSignatureForTerm :: Reference -> BackendError
type Backend m a = ExceptT BackendError m a
basicNames' :: Branch m -> NameScoping -> (Names, Names)
basicSuffixifiedNames :: Int -> Branch m -> NameScoping -> PrettyPrintEnv
basicPrettyPrintNames :: Branch m -> NameScoping -> Names
basicParseNames :: Branch m -> NameScoping -> Names
loadReferentType :: Applicative m => Codebase m Symbol Ann -> Referent -> m (Maybe (Type Symbol Ann))
getRootBranch :: Functor m => Codebase m v Ann -> Backend m (Branch m)
data TermEntry v a
TermEntry :: Referent -> HQSegment -> Maybe (Type v a) -> Maybe TermTag -> TermEntry v a
[termEntryReferent] :: TermEntry v a -> Referent
[termEntryName] :: TermEntry v a -> HQSegment
[termEntryType] :: TermEntry v a -> Maybe (Type v a)
[termEntryTag] :: TermEntry v a -> Maybe TermTag
data TypeEntry
TypeEntry :: Reference -> HQSegment -> TypeTag -> TypeEntry
[typeEntryReference] :: TypeEntry -> Reference
[typeEntryName] :: TypeEntry -> HQSegment
[typeEntryTag] :: TypeEntry -> TypeTag
data FoundRef
FoundTermRef :: Referent -> FoundRef
FoundTypeRef :: Reference -> FoundRef
fuzzyFind :: Monad m => Path -> Branch m -> String -> [(Alignment, UnisonName, [FoundRef])]
findShallow :: Monad m => Codebase m Symbol Ann -> Absolute -> Backend m [ShallowListEntry Symbol Ann]
findShallowReadmeInBranchAndRender :: Width -> Runtime Symbol -> Codebase IO Symbol Ann -> NamesWithHistory -> Branch IO -> Backend IO (Maybe Doc)
isDoc :: Monad m => Codebase m Symbol Ann -> Referent -> m Bool
isDoc' :: (Var v, Monoid loc) => Maybe (Type v loc) -> Bool
termListEntry :: Monad m => Codebase m Symbol Ann -> Branch0 m -> Referent -> HQSegment -> Backend m (TermEntry Symbol Ann)
typeListEntry :: Monad m => Var v => Codebase m v Ann -> Reference -> HQSegment -> Backend m TypeEntry
typeDeclHeader :: forall v m. Monad m => Var v => Codebase m v Ann -> PrettyPrintEnv -> Reference -> Backend m (DisplayObject SyntaxText SyntaxText)
formatTypeName :: PrettyPrintEnv -> Reference -> SyntaxText
formatTypeName' :: PrettyPrintEnv -> Reference -> SyntaxText
termEntryToNamedTerm :: Var v => PrettyPrintEnv -> Maybe Width -> TermEntry v a -> NamedTerm
typeEntryToNamedType :: TypeEntry -> NamedType
findShallowInBranch :: Monad m => Codebase m Symbol Ann -> Branch m -> Backend m [ShallowListEntry Symbol Ann]
termReferencesByShortHash :: Monad m => Codebase m v a -> ShortHash -> m (Set Reference)

-- | Look up types in the codebase by short hash, and include builtins.
typeReferencesByShortHash :: Monad m => Codebase m v a -> ShortHash -> m (Set Reference)

-- | Look up terms in the codebase by short hash, and include builtins.
termReferentsByShortHash :: Monad m => Codebase m v a -> ShortHash -> m (Set Referent)

-- | Configure how names will be constructed and filtered. this is
--   typically used when fetching names for printing source code or when
--   finding definitions by name.
data NameScoping

-- | Find all names, making any names which are children of this path,
--   otherwise leave them absolute.
AllNames :: Path -> NameScoping

-- | Filter returned names to only include names within this path.
Within :: Path -> NameScoping
toAllNames :: NameScoping -> NameScoping
getCurrentPrettyNames :: NameScoping -> Branch m -> NamesWithHistory
getCurrentParseNames :: NameScoping -> Branch m -> NamesWithHistory
fixupNamesRelative :: Absolute -> Names -> Names

-- | A <tt>Search r</tt> is a small bag of functions that is used to power
--   a search for <tt>r</tt>s.
--   
--   Construct a <a>Search</a> with <a>makeTypeSearch</a> or
--   <a>makeTermSearch</a>, and eliminate it with <a>applySearch</a>.
data Search r
Search :: (r -> Set (HashQualified Name)) -> (HashQualified Name -> Set r) -> (HashQualified Name -> r -> Set (HashQualified Name) -> SearchResult) -> (Name -> r -> HashQualified Name -> Bool) -> Search r
[lookupNames] :: Search r -> r -> Set (HashQualified Name)
[lookupRelativeHQRefs'] :: Search r -> HashQualified Name -> Set r
[makeResult] :: Search r -> HashQualified Name -> r -> Set (HashQualified Name) -> SearchResult
[matchesNamedRef] :: Search r -> Name -> r -> HashQualified Name -> Bool

-- | Make a type search, given a short hash length and names to search in.
makeTypeSearch :: Int -> NamesWithHistory -> Search Reference

-- | Make a term search, given a short hash length and names to search in.
makeTermSearch :: Int -> NamesWithHistory -> Search Referent

-- | Interpret a <a>Search</a> as a function from name to search results.
applySearch :: Show r => Search r -> HashQualified Name -> [SearchResult]
hqNameQuery :: Monad m => NameScoping -> Branch m -> Codebase m v Ann -> [HashQualified Name] -> m QueryResult
data DefinitionResults v
DefinitionResults :: Map Reference (DisplayObject (Type v Ann) (Term v Ann)) -> Map Reference (DisplayObject () (Decl v Ann)) -> [HashQualified Name] -> DefinitionResults v
[termResults] :: DefinitionResults v -> Map Reference (DisplayObject (Type v Ann) (Term v Ann))
[typeResults] :: DefinitionResults v -> Map Reference (DisplayObject () (Decl v Ann))
[noResults] :: DefinitionResults v -> [HashQualified Name]
expandShortBranchHash :: Monad m => Codebase m v a -> ShortBranchHash -> Backend m Hash
formatType' :: Var v => PrettyPrintEnv -> Width -> Type v a -> SyntaxText
formatType :: Var v => PrettyPrintEnv -> Width -> Type v a -> SyntaxText
formatSuffixedType :: Var v => PrettyPrintEnvDecl -> Width -> Type v Ann -> SyntaxText
mungeSyntaxText :: Functor g => g (Element Reference) -> g Element
prettyDefinitionsBySuffixes :: NameScoping -> Maybe Hash -> Maybe Width -> Suffixify -> Runtime Symbol -> Codebase IO Symbol Ann -> [HashQualified Name] -> Backend IO DefinitionDisplayResults
renderDoc :: PrettyPrintEnvDecl -> Width -> Runtime Symbol -> Codebase IO Symbol Ann -> Reference -> IO (HashQualifiedName, UnisonHash, Doc)
docsInBranchToHtmlFiles :: Runtime Symbol -> Codebase IO Symbol Ann -> Branch IO -> Path -> FilePath -> IO ()
bestNameForTerm :: forall v. Var v => PrettyPrintEnv -> Width -> Referent -> Text
bestNameForType :: forall v. Var v => PrettyPrintEnv -> Width -> Reference -> Text
resolveBranchHash :: Monad m => Maybe Hash -> Codebase m v Ann -> Backend m (Branch m)
resolveRootBranchHash :: Monad m => Maybe ShortBranchHash -> Codebase m v Ann -> Backend m (Branch m)

-- | Determines whether we include full cycles in the results, (e.g. if I
--   search for <tt>isEven</tt>, will I find <tt>isOdd</tt> too?)
data IncludeCycles
IncludeCycles :: IncludeCycles
DontIncludeCycles :: IncludeCycles
definitionsBySuffixes :: forall m. MonadIO m => NameScoping -> Branch m -> Codebase m Symbol Ann -> IncludeCycles -> [HashQualified Name] -> m (DefinitionResults Symbol)
termsToSyntax :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> Map Reference (DisplayObject (Type v a) (Term v a)) -> Map Reference (DisplayObject SyntaxText SyntaxText)
typesToSyntax :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a)) -> Map Reference (DisplayObject SyntaxText SyntaxText)
loadSearchResults :: Applicative m => Codebase m Symbol Ann -> [SearchResult] -> m [SearchResult' Symbol Ann]
loadTypeDisplayObject :: Applicative m => Codebase m v Ann -> Reference -> m (DisplayObject () (Decl v Ann))
instance GHC.Generics.Generic (Unison.Server.Backend.TermEntry v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Backend.TermEntry v a)
instance Unison.ABT.Var v => GHC.Classes.Ord (Unison.Server.Backend.TermEntry v a)
instance Unison.ABT.Var v => GHC.Classes.Eq (Unison.Server.Backend.TermEntry v a)
instance GHC.Generics.Generic Unison.Server.Backend.TypeEntry
instance GHC.Show.Show Unison.Server.Backend.TypeEntry
instance GHC.Classes.Ord Unison.Server.Backend.TypeEntry
instance GHC.Classes.Eq Unison.Server.Backend.TypeEntry
instance GHC.Generics.Generic (Unison.Server.Backend.ShallowListEntry v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Backend.ShallowListEntry v a)
instance Unison.ABT.Var v => GHC.Classes.Ord (Unison.Server.Backend.ShallowListEntry v a)
instance Unison.ABT.Var v => GHC.Classes.Eq (Unison.Server.Backend.ShallowListEntry v a)
instance GHC.Generics.Generic Unison.Server.Backend.FoundRef
instance GHC.Show.Show Unison.Server.Backend.FoundRef
instance GHC.Classes.Ord Unison.Server.Backend.FoundRef
instance GHC.Classes.Eq Unison.Server.Backend.FoundRef

module Unison.Server.Errors
badHQN :: HashQualifiedName -> ServerError
backendError :: BackendError -> ServerError
rootBranchError :: GetRootBranchError -> ServerError
badNamespace :: String -> String -> ServerError
noSuchNamespace :: HashQualifiedName -> ServerError
couldntLoadBranch :: Hash -> ServerError
ambiguousNamespace :: HashQualifiedName -> Set HashQualifiedName -> ServerError
missingSigForTerm :: HashQualifiedName -> ServerError

module Unison.Server.Endpoints.Projects
type ProjectsAPI = "projects" :> QueryParam "rootBranch" ShortBranchHash :> APIGet [ProjectListing]
newtype ProjectOwner
ProjectOwner :: Text -> ProjectOwner
data ProjectListing
ProjectListing :: ProjectOwner -> Text -> UnisonHash -> ProjectListing
[owner] :: ProjectListing -> ProjectOwner
[name] :: ProjectListing -> Text
[hash] :: ProjectListing -> UnisonHash
backendListEntryToProjectListing :: ProjectOwner -> ShallowListEntry Symbol a -> Maybe ProjectListing
entryToOwner :: ShallowListEntry Symbol a -> Maybe ProjectOwner
serve :: Handler () -> Codebase IO Symbol Ann -> Maybe ShortBranchHash -> Handler (APIHeaders [ProjectListing])
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.Projects.ProjectOwner
instance GHC.Show.Show Unison.Server.Endpoints.Projects.ProjectOwner
instance GHC.Generics.Generic Unison.Server.Endpoints.Projects.ProjectOwner
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.Projects.ProjectListing
instance GHC.Show.Show Unison.Server.Endpoints.Projects.ProjectListing
instance GHC.Generics.Generic Unison.Server.Endpoints.Projects.ProjectListing
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.Projects.ProjectListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.Projects.ProjectListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.Projects.ProjectOwner

module Unison.Server.Endpoints.NamespaceListing
type NamespaceListingAPI = "list" :> QueryParam "rootBranch" ShortBranchHash :> QueryParam "relativeTo" NamespaceFQN :> QueryParam "namespace" NamespaceFQN :> APIGet NamespaceListing
data NamespaceListing
NamespaceListing :: UnisonName -> UnisonHash -> [NamespaceObject] -> NamespaceListing
[namespaceListingFQN] :: NamespaceListing -> UnisonName
[namespaceListingHash] :: NamespaceListing -> UnisonHash
[namespaceListingChildren] :: NamespaceListing -> [NamespaceObject]
data NamespaceObject
Subnamespace :: NamedNamespace -> NamespaceObject
TermObject :: NamedTerm -> NamespaceObject
TypeObject :: NamedType -> NamespaceObject
PatchObject :: NamedPatch -> NamespaceObject
data NamedNamespace
NamedNamespace :: UnisonName -> UnisonHash -> Size -> NamedNamespace
[namespaceName] :: NamedNamespace -> UnisonName
[namespaceHash] :: NamedNamespace -> UnisonHash
[namespaceSize] :: NamedNamespace -> Size
newtype NamedPatch
NamedPatch :: HashQualifiedName -> NamedPatch
[patchName] :: NamedPatch -> HashQualifiedName
newtype KindExpression
KindExpression :: Text -> KindExpression
[kindExpressionText] :: KindExpression -> Text
backendListEntryToNamespaceObject :: Var v => PrettyPrintEnv -> Maybe Width -> ShallowListEntry v a -> NamespaceObject
serve :: Handler () -> Codebase IO Symbol Ann -> Maybe ShortBranchHash -> Maybe NamespaceFQN -> Maybe NamespaceFQN -> Handler (APIHeaders NamespaceListing)
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.KindExpression
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceListing.KindExpression
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceListing.KindExpression
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.KindExpression
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamespaceObject
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamedPatch
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceListing.NamedNamespace
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "namespace" Data.Text.Internal.Text)

module Unison.Server.Endpoints.NamespaceDetails
type NamespaceDetailsAPI = "namespaces" :> Capture "namespace" NamespaceFQN :> QueryParam "rootBranch" ShortBranchHash :> QueryParam "renderWidth" Width :> APIGet NamespaceDetails
data NamespaceDetails
NamespaceDetails :: UnisonName -> UnisonHash -> Maybe Doc -> NamespaceDetails
[fqn] :: NamespaceDetails -> UnisonName
[hash] :: NamespaceDetails -> UnisonHash
[readme] :: NamespaceDetails -> Maybe Doc
serve :: Handler () -> Runtime Symbol -> Codebase IO Symbol Ann -> NamespaceFQN -> Maybe ShortBranchHash -> Maybe Width -> Handler (APIHeaders NamespaceDetails)
instance GHC.Show.Show Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance GHC.Generics.Generic Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.NamespaceDetails.NamespaceDetails
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "namespace" Data.Text.Internal.Text)

module Unison.Server.Endpoints.GetDefinitions
type DefinitionsAPI = "getDefinition" :> QueryParam "rootBranch" ShortBranchHash :> QueryParam "relativeTo" NamespaceFQN :> QueryParams "names" HashQualifiedName :> QueryParam "renderWidth" Width :> QueryParam "suffixifyBindings" Suffixify :> APIGet DefinitionDisplayResults
serveDefinitions :: Handler () -> Runtime Symbol -> Codebase IO Symbol Ann -> Maybe ShortBranchHash -> Maybe NamespaceFQN -> [HashQualifiedName] -> Maybe Width -> Maybe Suffixify -> Handler (APIHeaders DefinitionDisplayResults)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "renderWidth" Unison.Util.Pretty.Width)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "suffixifyBindings" Unison.Server.Types.Suffixify)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "relativeTo" Unison.Server.Types.NamespaceFQN)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "rootBranch" Unison.Codebase.ShortBranchHash.ShortBranchHash)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParams "names" Data.Text.Internal.Text)
instance Servant.Docs.Internal.ToSample Unison.Server.Types.DefinitionDisplayResults

module Unison.Server.Endpoints.FuzzyFind
type FuzzyFindAPI = "find" :> QueryParam "rootBranch" ShortBranchHash :> QueryParam "relativeTo" HashQualifiedName :> QueryParam "limit" Int :> QueryParam "renderWidth" Width :> QueryParam "query" String :> APIGet [(Alignment, FoundResult)]
data FoundTerm
FoundTerm :: HashQualifiedName -> NamedTerm -> FoundTerm
[bestFoundTermName] :: FoundTerm -> HashQualifiedName
[namedTerm] :: FoundTerm -> NamedTerm
data FoundType
FoundType :: HashQualifiedName -> DisplayObject SyntaxText SyntaxText -> NamedType -> FoundType
[bestFoundTypeName] :: FoundType -> HashQualifiedName
[typeDef] :: FoundType -> DisplayObject SyntaxText SyntaxText
[namedType] :: FoundType -> NamedType
data FoundResult
FoundTermResult :: FoundTerm -> FoundResult
FoundTypeResult :: FoundType -> FoundResult
serveFuzzyFind :: Handler () -> Codebase IO Symbol Ann -> Maybe ShortBranchHash -> Maybe HashQualifiedName -> Maybe Int -> Maybe Width -> Maybe String -> Handler (APIHeaders [(Alignment, FoundResult)])
instance GHC.Show.Show Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance GHC.Generics.Generic Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance GHC.Show.Show Unison.Server.Endpoints.FuzzyFind.FoundType
instance GHC.Generics.Generic Unison.Server.Endpoints.FuzzyFind.FoundType
instance GHC.Show.Show Unison.Server.Endpoints.FuzzyFind.FoundResult
instance GHC.Generics.Generic Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.Alignment
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.Result
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.ResultSegment
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.FuzzyFind.FoundType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Servant.Docs.Internal.ToSample Unison.Server.Endpoints.FuzzyFind.FoundResult
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.FuzzyFind.FoundType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Endpoints.FuzzyFind.FoundTerm
instance Servant.Docs.Internal.ToSample Text.FuzzyFind.Alignment
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "limit" GHC.Types.Int)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "query" GHC.Base.String)
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.Alignment
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.Result
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.ResultSegment

module Unison.Server.CodebaseServer
data HTML
HTML :: HTML
newtype RawHtml
RawHtml :: ByteString -> RawHtml
[unRaw] :: RawHtml -> ByteString
type OpenApiJSON = "openapi.json" :> Get '[JSON] OpenApi
type DocAPI = UnisonAPI :<|> OpenApiJSON :<|> Raw
type UnisonAPI = NamespaceListingAPI :<|> NamespaceDetailsAPI :<|> ProjectsAPI :<|> DefinitionsAPI :<|> FuzzyFindAPI
type WebUI = CaptureAll "route" Text :> Get '[HTML] RawHtml
type ServerAPI = ("ui" :> WebUI) :<|> ("api" :> DocAPI)
type AuthedServerAPI = ("static" :> Raw) :<|> (Capture "token" Text :> ServerAPI)
data BaseUrl
BaseUrl :: String -> ByteString -> Port -> BaseUrl
[urlHost] :: BaseUrl -> String
[urlToken] :: BaseUrl -> ByteString
[urlPort] :: BaseUrl -> Port
data BaseUrlPath
UI :: BaseUrlPath
Api :: BaseUrlPath
urlFor :: BaseUrlPath -> BaseUrl -> String
handleAuth :: ByteString -> Text -> Handler ()
openAPI :: OpenApi
infoObject :: Info
docsBS :: ByteString
docAPI :: Proxy DocAPI
api :: Proxy UnisonAPI
serverAPI :: Proxy AuthedServerAPI
app :: Runtime Symbol -> Codebase IO Symbol Ann -> FilePath -> ByteString -> Application
genToken :: IO ByteString
data Waiter a
Waiter :: (a -> IO ()) -> IO a -> Waiter a
[notify] :: Waiter a -> a -> IO ()
[waitFor] :: Waiter a -> IO a
mkWaiter :: IO (Waiter a)
ucmUIVar :: String
ucmPortVar :: String
ucmHostVar :: String
ucmTokenVar :: String
data CodebaseServerOpts
CodebaseServerOpts :: Maybe String -> Maybe String -> Maybe Int -> Maybe FilePath -> CodebaseServerOpts
[token] :: CodebaseServerOpts -> Maybe String
[host] :: CodebaseServerOpts -> Maybe String
[port] :: CodebaseServerOpts -> Maybe Int
[codebaseUIPath] :: CodebaseServerOpts -> Maybe FilePath
startServer :: CodebaseServerOpts -> Runtime Symbol -> Codebase IO Symbol Ann -> (BaseUrl -> IO ()) -> IO ()
serveIndex :: FilePath -> Handler RawHtml
serveUI :: Handler () -> FilePath -> Server WebUI
server :: Runtime Symbol -> Codebase IO Symbol Ann -> FilePath -> ByteString -> Server AuthedServerAPI
instance GHC.Classes.Eq Unison.Server.CodebaseServer.CodebaseServerOpts
instance GHC.Show.Show Unison.Server.CodebaseServer.CodebaseServerOpts
instance GHC.Show.Show Unison.Server.CodebaseServer.BaseUrl
instance Servant.API.ContentTypes.MimeRender Unison.Server.CodebaseServer.HTML Unison.Server.CodebaseServer.RawHtml
instance Servant.API.ContentTypes.Accept Unison.Server.CodebaseServer.HTML
instance Servant.Docs.Internal.ToSample GHC.Types.Char

module Unison.Util.TQueue
data TQueue a
TQueue :: TVar (Seq a) -> TVar Word64 -> TQueue a
newIO :: MonadIO m => m (TQueue a)
size :: TQueue a -> STM Int
awaitSize :: Int -> TQueue a -> STM ()
peek :: TQueue a -> STM a
dequeue :: TQueue a -> STM a
undequeue :: TQueue a -> a -> STM ()
tryDequeue :: TQueue a -> STM (Maybe a)
dequeueN :: TQueue a -> Int -> STM [a]
enqueueCount :: TQueue a -> STM Word64
flush :: TQueue a -> STM [a]
enqueue :: TQueue a -> a -> STM ()
raceIO :: MonadIO m => STM a -> STM b -> m (Either a b)
tryPeekWhile :: (a -> Bool) -> TQueue a -> STM [a]
takeWhile :: (a -> Bool) -> TQueue a -> STM [a]
peekWhile :: (a -> Bool) -> TQueue a -> STM [a]

module Unison.Codebase.Watch
untilJust :: Monad m => m (Maybe a) -> m a
watchDirectory' :: forall m. MonadIO m => FilePath -> m (IO (), IO (FilePath, UTCTime))
collectUntilPause :: forall a. TQueue a -> Int -> IO [a]
watchDirectory :: forall m. MonadIO m => FilePath -> (FilePath -> Bool) -> m (IO (), IO (FilePath, Text))

module Unison.Util.Text
newtype Text
Text :: Rope Chunk -> Text
data Chunk
Chunk :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Text -> Chunk
empty :: Text
one :: Char -> Text
singleton :: Char -> Text
threshold :: Int
replicate :: Int -> Text -> Text
chunkToText :: Chunk -> Text
chunk :: Text -> Chunk
take :: Int -> Text -> Text
drop :: Int -> Text -> Text
uncons :: Text -> Maybe (Char, Text)
unsnoc :: Text -> Maybe (Text, Char)
at :: Int -> Text -> Maybe Char
size :: Text -> Int
reverse :: Text -> Text
fromUtf8 :: Bytes -> Either String Text
toUtf8 :: Text -> Bytes
fromText :: Text -> Text
pack :: String -> Text
toString :: Text -> String
unpack :: Text -> String
toText :: Text -> Text
instance GHC.Base.Monoid Unison.Util.Text.Text
instance GHC.Base.Semigroup Unison.Util.Text.Text
instance GHC.Classes.Ord Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Text
instance Unison.Util.Rope.Sized Unison.Util.Text.Text
instance GHC.Show.Show Unison.Util.Text.Text
instance Data.String.IsString Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Chunk
instance GHC.Classes.Ord Unison.Util.Text.Chunk
instance GHC.Base.Semigroup Unison.Util.Text.Chunk
instance GHC.Base.Monoid Unison.Util.Text.Chunk
instance Unison.Util.Rope.Sized Unison.Util.Text.Chunk
instance Unison.Util.Rope.Drop Unison.Util.Text.Chunk
instance Unison.Util.Rope.Take Unison.Util.Text.Chunk
instance Unison.Util.Rope.Index Unison.Util.Text.Chunk GHC.Types.Char
instance Unison.Util.Rope.Reverse Unison.Util.Text.Chunk

module Unison.Runtime.ANF
minimizeCyclesOrCrash :: Var v => Term v a -> Term v a
pattern TVar :: Var v => v -> Term ANormalF v
pattern TLit :: Var v => Lit -> Term ANormalF v
pattern TApp :: Var v => Func v -> [v] -> Term ANormalF v
pattern TApv :: Var v => v -> [v] -> Term ANormalF v
pattern TCom :: Var v => Reference -> [v] -> Term ANormalF v
pattern TCon :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TKon :: Var v => v -> [v] -> Term ANormalF v
pattern TReq :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TPrm :: Var v => POp -> [v] -> Term ANormalF v
pattern TFOp :: Var v => FOp -> [v] -> Term ANormalF v
pattern THnd :: Var v => [Reference] -> v -> Term ANormalF v -> Term ANormalF v
pattern TLet :: Var v => Direction Word16 -> v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TLetD :: Var v => v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TFrc :: Var v => v -> Term ANormalF v
pattern TLets :: Var v => Direction Word16 -> [v] -> [Mem] -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TName :: Var v => v -> Either Reference v -> [v] -> Term ANormalF v -> Term ANormalF v
pattern TBind :: Var v => Cte v -> ANormal v -> ANormal v
pattern TBinds :: Var v => [Cte v] -> ANormal v -> ANormal v
pattern TShift :: Var v => Reference -> v -> Term ANormalF v -> Term ANormalF v
pattern TMatch :: Var v => v -> Branched (Term ANormalF v) -> Term ANormalF v
data CompileExn
CE :: CallStack -> Pretty ColorText -> CompileExn
internalBug :: HasCallStack => String -> a
data Mem
UN :: Mem
BX :: Mem
data Lit
I :: Int64 -> Lit
N :: Word64 -> Lit
F :: Double -> Lit
T :: Text -> Lit
C :: Char -> Lit
LM :: Referent -> Lit
LY :: Reference -> Lit
data Direction a
Indirect :: a -> Direction a
Direct :: Direction a
data SuperNormal v
Lambda :: [Mem] -> ANormal v -> SuperNormal v
[conventions] :: SuperNormal v -> [Mem]
[bound] :: SuperNormal v -> ANormal v
data SuperGroup v
Rec :: [(v, SuperNormal v)] -> SuperNormal v -> SuperGroup v
[group] :: SuperGroup v -> [(v, SuperNormal v)]
[entry] :: SuperGroup v -> SuperNormal v
data POp
ADDI :: POp
SUBI :: POp
MULI :: POp
DIVI :: POp
SGNI :: POp
NEGI :: POp
MODI :: POp
POWI :: POp
SHLI :: POp
SHRI :: POp
INCI :: POp
DECI :: POp
LEQI :: POp
EQLI :: POp
ADDN :: POp
SUBN :: POp
MULN :: POp
DIVN :: POp
MODN :: POp
TZRO :: POp
LZRO :: POp
POPC :: POp
POWN :: POp
SHLN :: POp
SHRN :: POp
ANDN :: POp
IORN :: POp
XORN :: POp
COMN :: POp
INCN :: POp
DECN :: POp
LEQN :: POp
EQLN :: POp
ADDF :: POp
SUBF :: POp
MULF :: POp
DIVF :: POp
MINF :: POp
MAXF :: POp
LEQF :: POp
EQLF :: POp
POWF :: POp
EXPF :: POp
SQRT :: POp
LOGF :: POp
LOGB :: POp
ABSF :: POp
CEIL :: POp
FLOR :: POp
TRNF :: POp
RNDF :: POp
COSF :: POp
ACOS :: POp
COSH :: POp
ACSH :: POp
SINF :: POp
ASIN :: POp
SINH :: POp
ASNH :: POp
TANF :: POp
ATAN :: POp
TANH :: POp
ATNH :: POp
ATN2 :: POp
CATT :: POp
TAKT :: POp
DRPT :: POp
SIZT :: POp
UCNS :: POp
USNC :: POp
EQLT :: POp
LEQT :: POp
PAKT :: POp
UPKT :: POp
CATS :: POp
TAKS :: POp
DRPS :: POp
SIZS :: POp
CONS :: POp
SNOC :: POp
IDXS :: POp
BLDS :: POp
VWLS :: POp
VWRS :: POp
SPLL :: POp
SPLR :: POp
PAKB :: POp
UPKB :: POp
TAKB :: POp
DRPB :: POp
IDXB :: POp
SIZB :: POp
FLTB :: POp
CATB :: POp
ITOF :: POp
NTOF :: POp
ITOT :: POp
NTOT :: POp
TTOI :: POp
TTON :: POp
TTOF :: POp
FTOT :: POp
FORK :: POp
EQLU :: POp
CMPU :: POp
EROR :: POp
MISS :: POp
CACH :: POp
LKUP :: POp
LOAD :: POp
CVLD :: POp
VALU :: POp
TLTT :: POp
PRNT :: POp
INFO :: POp
TRCE :: POp
ATOM :: POp
type FOp = Word64
close :: (Var v, Monoid a) => Set v -> Term v a -> Term v a
saturate :: (Var v, Monoid a) => Map ConstructorReference Int -> Term v a -> Term v a
float :: (Var v, Monoid a) => Term v a -> (Term v a, [(v, Term v a)])
lamLift :: (Var v, Monoid a) => Term v a -> (Term v a, [(v, Term v a)])
inlineAlias :: Var v => Monoid a => Term v a -> Term v a
addDefaultCases :: Var v => Monoid a => String -> Term v a -> Term v a
data ANormalF v e
ALet :: Direction Word16 -> [Mem] -> e -> e -> ANormalF v e
AName :: Either Reference v -> [v] -> e -> ANormalF v e
ALit :: Lit -> ANormalF v e
AMatch :: v -> Branched e -> ANormalF v e
AShift :: Reference -> e -> ANormalF v e
AHnd :: [Reference] -> v -> e -> ANormalF v e
AApp :: Func v -> [v] -> ANormalF v e
AFrc :: v -> ANormalF v e
AVar :: v -> ANormalF v e
pattern AApv :: v -> [v] -> ANormalF v e
pattern ACom :: Reference -> [v] -> ANormalF v e
pattern ACon :: Reference -> CTag -> [v] -> ANormalF v e
pattern AKon :: v -> [v] -> ANormalF v e
pattern AReq :: Reference -> CTag -> [v] -> ANormalF v e
pattern APrm :: POp -> [v] -> ANormalF v e
pattern AFOp :: FOp -> [v] -> ANormalF v e
type ANormal = Term ANormalF
data RTag
data CTag
class Tag t
rawTag :: Tag t => t -> Word64
data GroupRef
GR :: Reference -> Word64 -> GroupRef
data Value
Partial :: GroupRef -> [Word64] -> [Value] -> Value
Data :: Reference -> Word64 -> [Word64] -> [Value] -> Value
Cont :: [Word64] -> [Value] -> Cont -> Value
BLit :: BLit -> Value
data Cont
KE :: Cont
Mark :: [Reference] -> Map Reference Value -> Cont -> Cont
Push :: Word64 -> Word64 -> Word64 -> Word64 -> GroupRef -> Cont -> Cont
data BLit
Text :: Text -> BLit
List :: Seq Value -> BLit
TmLink :: Referent -> BLit
TyLink :: Reference -> BLit
Bytes :: Bytes -> BLit
packTags :: RTag -> CTag -> Word64
unpackTags :: Word64 -> (RTag, CTag)
maskTags :: Word64 -> Word64
type ANFM v = ReaderT (Set v) (State (Word64, Word16, [(v, SuperNormal v)]))
data Branched e
MatchIntegral :: EnumMap Word64 e -> Maybe e -> Branched e
MatchText :: Map Text e -> Maybe e -> Branched e
MatchRequest :: Map Reference (EnumMap CTag ([Mem], e)) -> e -> Branched e
MatchEmpty :: Branched e
MatchData :: Reference -> EnumMap CTag ([Mem], e) -> Maybe e -> Branched e
MatchSum :: EnumMap Word64 ([Mem], e) -> Branched e
pattern MatchDataCover :: Reference -> EnumMap CTag ([Mem], e) -> Branched e
data Func v
FVar :: v -> Func v
FComb :: !Reference -> Func v
FCont :: v -> Func v
FCon :: !Reference -> !CTag -> Func v
FReq :: !Reference -> !CTag -> Func v
FPrim :: Either POp FOp -> Func v
superNormalize :: Var v => Term v a -> SuperGroup v
anfTerm :: Var v => Term v a -> ANFM v (DNormal v)
valueTermLinks :: Value -> [Reference]
valueLinks :: Monoid a => (Bool -> Reference -> a) -> Value -> a
groupTermLinks :: SuperGroup v -> [Reference]
groupLinks :: Monoid a => (Bool -> Reference -> a) -> SuperGroup v -> a
normalLinks :: Monoid a => (Bool -> Reference -> a) -> SuperNormal v -> a
prettyGroup :: Var v => String -> SuperGroup v -> ShowS
instance GHC.Show.Show Unison.Runtime.ANF.CompileExn
instance GHC.Enum.Enum Unison.Runtime.ANF.Mem
instance GHC.Show.Show Unison.Runtime.ANF.Mem
instance GHC.Classes.Ord Unison.Runtime.ANF.Mem
instance GHC.Classes.Eq Unison.Runtime.ANF.Mem
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.RTag
instance GHC.Read.Read Unison.Runtime.ANF.RTag
instance GHC.Show.Show Unison.Runtime.ANF.RTag
instance GHC.Classes.Ord Unison.Runtime.ANF.RTag
instance GHC.Classes.Eq Unison.Runtime.ANF.RTag
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.CTag
instance GHC.Read.Read Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.CTag
instance GHC.Classes.Ord Unison.Runtime.ANF.CTag
instance GHC.Classes.Eq Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.SeqEnd
instance GHC.Enum.Enum Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Ord Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Eq Unison.Runtime.ANF.SeqEnd
instance Data.Traversable.Traversable Unison.Runtime.ANF.Branched
instance Data.Foldable.Foldable Unison.Runtime.ANF.Branched
instance GHC.Base.Functor Unison.Runtime.ANF.Branched
instance GHC.Show.Show e => GHC.Show.Show (Unison.Runtime.ANF.Branched e)
instance GHC.Show.Show Unison.Runtime.ANF.Lit
instance GHC.Classes.Ord Unison.Runtime.ANF.POp
instance GHC.Classes.Eq Unison.Runtime.ANF.POp
instance GHC.Show.Show Unison.Runtime.ANF.POp
instance Data.Traversable.Traversable Unison.Runtime.ANF.Func
instance Data.Foldable.Foldable Unison.Runtime.ANF.Func
instance GHC.Base.Functor Unison.Runtime.ANF.Func
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Func v)
instance Data.Traversable.Traversable Unison.Runtime.ANF.Direction
instance Data.Foldable.Foldable Unison.Runtime.ANF.Direction
instance GHC.Base.Functor Unison.Runtime.ANF.Direction
instance GHC.Show.Show a => GHC.Show.Show (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Runtime.ANF.Direction a)
instance (GHC.Show.Show e, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show v, GHC.Show.Show s) => GHC.Show.Show (Unison.Runtime.ANF.CTE v s)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Show.Show Unison.Runtime.ANF.GroupRef
instance GHC.Show.Show Unison.Runtime.ANF.Cont
instance GHC.Show.Show Unison.Runtime.ANF.Value
instance GHC.Show.Show Unison.Runtime.ANF.BLit
instance GHC.Base.Semigroup (Unison.Runtime.ANF.BranchAccum v)
instance GHC.Base.Monoid (Unison.Runtime.ANF.BranchAccum e)
instance GHC.Base.Functor (Unison.Runtime.ANF.ANormalF v)
instance Data.Bifunctor.Bifunctor Unison.Runtime.ANF.ANormalF
instance Data.Bifoldable.Bifoldable Unison.Runtime.ANF.ANormalF
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Runtime.ANF.Direction a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Unison.Runtime.ANF.Direction a)
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.RTag
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.CTag
instance GHC.Num.Num Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.RTag
instance GHC.Num.Num Unison.Runtime.ANF.RTag
instance GHC.Exception.Type.Exception Unison.Runtime.ANF.CompileExn

module Unison.Runtime.Pattern
type DataSpec = Map Reference (Either Cons Cons)
splitPatterns :: Var v => DataSpec -> Term v -> Term v
builtinDataSpec :: DataSpec
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternRow v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternMatrix v)
instance GHC.Show.Show Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Ord Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Eq Unison.Runtime.Pattern.SeqMatch
instance GHC.Base.Semigroup Unison.Runtime.Pattern.PType
instance GHC.Base.Monoid Unison.Runtime.Pattern.PType

module Unison.Runtime.MCode
data Args'
Arg1 :: !Int -> Args'
Arg2 :: !Int -> !Int -> Args'
ArgN :: {-# UNPACK #-} !PrimArray Int -> Args'
ArgR :: !Int -> !Int -> Args'
data Args
ZArgs :: Args
UArg1 :: !Int -> Args
UArg2 :: !Int -> !Int -> Args
BArg1 :: !Int -> Args
BArg2 :: !Int -> !Int -> Args
DArg2 :: !Int -> !Int -> Args
UArgR :: !Int -> !Int -> Args
BArgR :: !Int -> !Int -> Args
DArgR :: !Int -> !Int -> !Int -> !Int -> Args
BArgN :: !PrimArray Int -> Args
UArgN :: !PrimArray Int -> Args
DArgN :: !PrimArray Int -> !PrimArray Int -> Args
DArgV :: !Int -> !Int -> Args
data RefNums
RN :: (Reference -> Word64) -> (Reference -> Word64) -> RefNums
[dnum] :: RefNums -> Reference -> Word64
[cnum] :: RefNums -> Reference -> Word64
data MLit
MI :: !Int -> MLit
MD :: !Double -> MLit
MT :: !Text -> MLit
MM :: !Referent -> MLit
MY :: !Reference -> MLit
data Instr
UPrim1 :: !UPrim1 -> !Int -> Instr
UPrim2 :: !UPrim2 -> !Int -> !Int -> Instr
BPrim1 :: !BPrim1 -> !Int -> Instr
BPrim2 :: !BPrim2 -> !Int -> !Int -> Instr
ForeignCall :: !Bool -> !Word64 -> !Args -> Instr
SetDyn :: !Word64 -> !Int -> Instr
Capture :: !Word64 -> Instr
Name :: !Ref -> !Args -> Instr
Info :: !String -> Instr
Pack :: !Reference -> !Word64 -> !Args -> Instr
Unpack :: !Maybe Reference -> !Int -> Instr
Lit :: !MLit -> Instr
Print :: !Int -> Instr
Reset :: !EnumSet Word64 -> Instr
Fork :: !Int -> Instr
Atomically :: !Int -> Instr
Seq :: !Args -> Instr
data Section
App :: !Bool -> !Ref -> !Args -> Section
Call :: !Bool -> !Word64 -> !Args -> Section
Jump :: !Int -> !Args -> Section
Match :: !Int -> !Branch -> Section
Yield :: !Args -> Section
Ins :: !Instr -> !Section -> Section
Let :: !Section -> !CombIx -> Section
Die :: String -> Section
Exit :: Section
pattern MatchT :: Int -> Section -> Map Text Section -> Section
pattern MatchW :: Int -> Section -> EnumMap Word64 Section -> Section
data Comb
Lam :: !Int -> !Int -> !Int -> !Int -> !Section -> Comb
type Combs = EnumMap Word64 Comb
data CombIx
CIx :: !Reference -> !Word64 -> !Word64 -> CombIx
data Ref
Stk :: !Int -> Ref
Env :: !Word64 -> !Word64 -> Ref
Dyn :: !Word64 -> Ref
data UPrim1
DECI :: UPrim1
INCI :: UPrim1
NEGI :: UPrim1
SGNI :: UPrim1
LZRO :: UPrim1
TZRO :: UPrim1
COMN :: UPrim1
POPC :: UPrim1
ABSF :: UPrim1
EXPF :: UPrim1
LOGF :: UPrim1
SQRT :: UPrim1
COSF :: UPrim1
ACOS :: UPrim1
COSH :: UPrim1
ACSH :: UPrim1
SINF :: UPrim1
ASIN :: UPrim1
SINH :: UPrim1
ASNH :: UPrim1
TANF :: UPrim1
ATAN :: UPrim1
TANH :: UPrim1
ATNH :: UPrim1
ITOF :: UPrim1
NTOF :: UPrim1
CEIL :: UPrim1
FLOR :: UPrim1
TRNF :: UPrim1
RNDF :: UPrim1
data UPrim2
ADDI :: UPrim2
SUBI :: UPrim2
MULI :: UPrim2
DIVI :: UPrim2
MODI :: UPrim2
DIVN :: UPrim2
MODN :: UPrim2
SHLI :: UPrim2
SHRI :: UPrim2
SHRN :: UPrim2
POWI :: UPrim2
EQLI :: UPrim2
LEQI :: UPrim2
LEQN :: UPrim2
ANDN :: UPrim2
IORN :: UPrim2
XORN :: UPrim2
EQLF :: UPrim2
LEQF :: UPrim2
ADDF :: UPrim2
SUBF :: UPrim2
MULF :: UPrim2
DIVF :: UPrim2
ATN2 :: UPrim2
POWF :: UPrim2
LOGB :: UPrim2
MAXF :: UPrim2
MINF :: UPrim2
data BPrim1
SIZT :: BPrim1
USNC :: BPrim1
UCNS :: BPrim1
ITOT :: BPrim1
NTOT :: BPrim1
FTOT :: BPrim1
TTOI :: BPrim1
TTON :: BPrim1
TTOF :: BPrim1
PAKT :: BPrim1
UPKT :: BPrim1
VWLS :: BPrim1
VWRS :: BPrim1
SIZS :: BPrim1
PAKB :: BPrim1
UPKB :: BPrim1
SIZB :: BPrim1
FLTB :: BPrim1
MISS :: BPrim1
CACH :: BPrim1
LKUP :: BPrim1
LOAD :: BPrim1
CVLD :: BPrim1
VALU :: BPrim1
TLTT :: BPrim1
data BPrim2
EQLU :: BPrim2
CMPU :: BPrim2
DRPT :: BPrim2
CATT :: BPrim2
TAKT :: BPrim2
EQLT :: BPrim2
LEQT :: BPrim2
LEST :: BPrim2
DRPS :: BPrim2
CATS :: BPrim2
TAKS :: BPrim2
CONS :: BPrim2
SNOC :: BPrim2
IDXS :: BPrim2
SPLL :: BPrim2
SPLR :: BPrim2
TAKB :: BPrim2
DRPB :: BPrim2
IDXB :: BPrim2
CATB :: BPrim2
THRO :: BPrim2
TRCE :: BPrim2
data Branch
Test1 :: !Word64 -> !Section -> !Section -> Branch
Test2 :: !Word64 -> !Section -> !Word64 -> !Section -> !Section -> Branch
TestW :: !Section -> !EnumMap Word64 Section -> Branch
TestT :: !Section -> !Map Text Section -> Branch
bcount :: Args -> Int
ucount :: Args -> Int
emitCombs :: Var v => RefNums -> Word64 -> SuperGroup v -> EnumMap Word64 Comb
emitComb :: Var v => RefNums -> Word64 -> RCtx v -> (Word64, SuperNormal v) -> EnumMap Word64 Comb
emptyRNs :: RefNums
argsToLists :: Args -> ([Int], [Int])
combDeps :: Comb -> [Word64]
combTypes :: Comb -> [Word64]
prettyCombs :: Word64 -> EnumMap Word64 Comb -> ShowS
prettyComb :: Word64 -> Word64 -> Comb -> ShowS
instance GHC.Show.Show Unison.Runtime.MCode.Args'
instance GHC.Classes.Ord Unison.Runtime.MCode.Args
instance GHC.Classes.Eq Unison.Runtime.MCode.Args
instance GHC.Show.Show Unison.Runtime.MCode.Args
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim1
instance GHC.Show.Show Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim2
instance GHC.Show.Show Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim1
instance GHC.Show.Show Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim2
instance GHC.Show.Show Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.MLit
instance GHC.Classes.Eq Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.CombIx
instance GHC.Classes.Eq Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.Ref
instance GHC.Classes.Eq Unison.Runtime.MCode.Ref
instance GHC.Show.Show Unison.Runtime.MCode.Ref
instance GHC.Classes.Ord Unison.Runtime.MCode.Instr
instance GHC.Classes.Eq Unison.Runtime.MCode.Instr
instance GHC.Show.Show Unison.Runtime.MCode.Instr
instance GHC.Classes.Ord Unison.Runtime.MCode.Section
instance GHC.Classes.Eq Unison.Runtime.MCode.Section
instance GHC.Show.Show Unison.Runtime.MCode.Section
instance GHC.Classes.Ord Unison.Runtime.MCode.Branch
instance GHC.Classes.Eq Unison.Runtime.MCode.Branch
instance GHC.Show.Show Unison.Runtime.MCode.Branch
instance GHC.Classes.Ord Unison.Runtime.MCode.Comb
instance GHC.Classes.Eq Unison.Runtime.MCode.Comb
instance GHC.Show.Show Unison.Runtime.MCode.Comb
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.MCode.Ctx v)
instance GHC.Base.Functor Unison.Runtime.MCode.Counted
instance GHC.Base.Functor Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Counted

module Unison.Runtime.Foreign
data Foreign
[Wrap] :: Reference -> !e -> Foreign
data HashAlgorithm
[HashAlgorithm] :: HashAlgorithm a => Reference -> a -> HashAlgorithm
unwrapForeign :: Foreign -> a
maybeUnwrapForeign :: Reference -> Foreign -> Maybe a
wrapBuiltin :: forall f. BuiltinForeign f => f -> Foreign
maybeUnwrapBuiltin :: forall f. BuiltinForeign f => Foreign -> Maybe f
unwrapBuiltin :: BuiltinForeign f => Foreign -> f
class BuiltinForeign f
foreignRef :: BuiltinForeign f => Tagged f Reference
newtype Tls
Tls :: Context -> Tls
data Failure a
Failure :: Reference -> Text -> a -> Failure a
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.Foreign.HashAlgorithm
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Text
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.BuiltinForeign Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.BuiltinForeign GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ClientParams
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ServerParams
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.SignedCertificate
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.PrivateKey.PrivKey
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.FilePath
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Context.Internal.Context
instance Unison.Runtime.Foreign.BuiltinForeign (Unison.Runtime.ANF.SuperGroup Unison.Symbol.Symbol)
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Value
instance GHC.Classes.Eq Unison.Runtime.Foreign.Foreign
instance GHC.Classes.Ord Unison.Runtime.Foreign.Foreign
instance GHC.Show.Show Unison.Runtime.Foreign.Foreign

module Unison.Runtime.Stack
data K
KE :: K
CB :: Callback -> K
Mark :: !EnumSet Word64 -> !EnumMap Word64 Closure -> !K -> K
Push :: !Int -> !Int -> !Int -> !Int -> !CombIx -> !K -> K
data Closure
PAp :: {-# UNPACK #-} !CombIx -> {-# UNPACK #-} !Seg 'UN -> !Seg 'BX -> Closure
Enum :: !Reference -> !Word64 -> Closure
DataU1 :: !Reference -> !Word64 -> !Int -> Closure
DataU2 :: !Reference -> !Word64 -> !Int -> !Int -> Closure
DataB1 :: !Reference -> !Word64 -> !Closure -> Closure
DataB2 :: !Reference -> !Word64 -> !Closure -> !Closure -> Closure
DataUB :: !Reference -> !Word64 -> !Int -> !Closure -> Closure
DataG :: !Reference -> !Word64 -> !Seg 'UN -> !Seg 'BX -> Closure
Captured :: !K -> {-# UNPACK #-} !Seg 'UN -> !Seg 'BX -> Closure
Foreign :: !Foreign -> Closure
BlackHole :: Closure
pattern DataC :: Reference -> Word64 -> [Int] -> [Closure] -> Closure
pattern PApV :: CombIx -> [Int] -> [Closure] -> Closure
pattern CapV :: K -> [Int] -> [Closure] -> Closure
newtype Callback
Hook :: (Stack 'UN -> Stack 'BX -> IO ()) -> Callback
data Augment
I :: Augment
K :: Augment
C :: Augment
data Dump
A :: Dump
F :: Int -> Dump
S :: Dump
class MEM (b :: Mem) where {
    data family Stack b :: *;
    type family Elem b :: *;
    type family Seg b :: *;
}
alloc :: MEM b => IO (Stack b)
peek :: MEM b => Stack b -> IO (Elem b)
peekOff :: MEM b => Stack b -> Off -> IO (Elem b)
poke :: MEM b => Stack b -> Elem b -> IO ()
pokeOff :: MEM b => Stack b -> Off -> Elem b -> IO ()
grab :: MEM b => Stack b -> SZ -> IO (Seg b, Stack b)
ensure :: MEM b => Stack b -> SZ -> IO (Stack b)
bump :: MEM b => Stack b -> IO (Stack b)
bumpn :: MEM b => Stack b -> SZ -> IO (Stack b)
duplicate :: MEM b => Stack b -> IO (Stack b)
discardFrame :: MEM b => Stack b -> IO (Stack b)
saveFrame :: MEM b => Stack b -> IO (Stack b, SZ, SZ)
restoreFrame :: MEM b => Stack b -> SZ -> SZ -> IO (Stack b)
prepareArgs :: MEM b => Stack b -> Args' -> IO (Stack b)
acceptArgs :: MEM b => Stack b -> Int -> IO (Stack b)
frameArgs :: MEM b => Stack b -> IO (Stack b)
augSeg :: MEM b => Augment -> Stack b -> Seg b -> Maybe Args' -> IO (Seg b)
dumpSeg :: MEM b => Stack b -> Seg b -> Dump -> IO (Stack b)
fsize :: MEM b => Stack b -> SZ
asize :: MEM b => Stack b -> SZ
type Off = Int
type SZ = Int
type FP = Int
marshalToForeign :: HasCallStack => Closure -> Foreign
unull :: Seg 'UN
bnull :: Seg 'BX
peekD :: Stack 'UN -> IO Double
peekOffD :: Stack 'UN -> Int -> IO Double
pokeD :: Stack 'UN -> Double -> IO ()
pokeOffD :: Stack 'UN -> Int -> Double -> IO ()
peekN :: Stack 'UN -> IO Word64
peekOffN :: Stack 'UN -> Int -> IO Word64
pokeN :: Stack 'UN -> Word64 -> IO ()
pokeOffN :: Stack 'UN -> Int -> Word64 -> IO ()
peekBi :: BuiltinForeign b => Stack 'BX -> IO b
peekOffBi :: BuiltinForeign b => Stack 'BX -> Int -> IO b
pokeBi :: BuiltinForeign b => Stack 'BX -> b -> IO ()
pokeOffBi :: BuiltinForeign b => Stack 'BX -> Int -> b -> IO ()
peekOffS :: Stack 'BX -> Int -> IO (Seq Closure)
pokeS :: Stack 'BX -> Seq Closure -> IO ()
pokeOffS :: Stack 'BX -> Int -> Seq Closure -> IO ()
frameView :: MEM b => Show (Elem b) => Stack b -> IO ()
uscount :: Seg 'UN -> Int
bscount :: Seg 'BX -> Int
instance GHC.Classes.Ord Unison.Runtime.Stack.Closure
instance GHC.Classes.Eq Unison.Runtime.Stack.Closure
instance GHC.Show.Show Unison.Runtime.Stack.Closure
instance GHC.Classes.Ord Unison.Runtime.Stack.K
instance GHC.Classes.Eq Unison.Runtime.Stack.K
instance GHC.Show.Show Unison.Runtime.Stack.K
instance Unison.Runtime.Stack.MEM 'Unison.Runtime.ANF.BX
instance GHC.Classes.Eq Unison.Runtime.Stack.Callback
instance GHC.Classes.Ord Unison.Runtime.Stack.Callback
instance Unison.Runtime.Stack.MEM 'Unison.Runtime.ANF.UN
instance GHC.Show.Show (Unison.Runtime.Stack.Stack 'Unison.Runtime.ANF.BX)
instance GHC.Show.Show (Unison.Runtime.Stack.Stack 'Unison.Runtime.ANF.UN)

module Unison.Runtime.Exception
data RuntimeExn
PE :: CallStack -> Pretty ColorText -> RuntimeExn
BU :: Text -> Closure -> RuntimeExn
die :: HasCallStack => String -> IO a
exn :: HasCallStack => String -> a
instance GHC.Show.Show Unison.Runtime.Exception.RuntimeExn
instance GHC.Exception.Type.Exception Unison.Runtime.Exception.RuntimeExn

module Unison.Runtime.Serialize
unknownTag :: MonadGet m => String -> Word8 -> m a
class Tag t
tag2word :: Tag t => t -> Word8
word2tag :: (Tag t, MonadGet m) => Word8 -> m t
putTag :: MonadPut m => Tag t => t -> m ()
getTag :: MonadGet m => Tag t => m t
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putLength :: (MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ()
getLength :: (MonadGet m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => m n
putFoldable :: (Foldable f, MonadPut m) => (a -> m ()) -> f a -> m ()
putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()
getList :: MonadGet m => m a -> m [a]
getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)
putEnumMap :: MonadPut m => EnumKey k => (k -> m ()) -> (v -> m ()) -> EnumMap k v -> m ()
getEnumMap :: MonadGet m => EnumKey k => m k -> m v -> m (EnumMap k v)
putEnumSet :: MonadPut m => EnumKey k => (k -> m ()) -> EnumSet k -> m ()
getEnumSet :: MonadGet m => EnumKey k => m k -> m (EnumSet k)
putMaybe :: MonadPut m => Maybe a -> (a -> m ()) -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ()
getPair :: MonadGet m => m a -> m b -> m (a, b)
getBytes :: MonadGet m => m Bytes
putBytes :: MonadPut m => Bytes -> m ()
getBlock :: MonadGet m => m Chunk
putBlock :: MonadPut m => Chunk -> m ()
putHash :: MonadPut m => Hash -> m ()
getHash :: MonadGet m => m Hash
putReferent :: MonadPut m => Referent -> m ()
getReferent :: MonadGet m => m Referent
getConstructorType :: MonadGet m => m ConstructorType
putConstructorType :: MonadPut m => ConstructorType -> m ()
putText :: MonadPut m => Text -> m ()
getText :: MonadGet m => m Text
putReference :: MonadPut m => Reference -> m ()
getReference :: MonadGet m => m Reference
putConstructorReference :: MonadPut m => ConstructorReference -> m ()
getConstructorReference :: MonadGet m => m ConstructorReference
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim2
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim2

module Unison.Runtime.MCode.Serialize
putComb :: MonadPut m => Comb -> m ()
getComb :: MonadGet m => m Comb
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.BranchT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.MLitT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.RefT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.ArgsT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.InstrT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.SectionT

module Unison.Runtime.Foreign.Function
data ForeignFunc
[FF] :: (Stack 'UN -> Stack 'BX -> Args -> IO a) -> (Stack 'UN -> Stack 'BX -> r -> IO (Stack 'UN, Stack 'BX)) -> (a -> IO r) -> ForeignFunc
class ForeignConvention a
readForeign :: ForeignConvention a => [Int] -> [Int] -> Stack 'UN -> Stack 'BX -> IO ([Int], [Int], a)
writeForeign :: ForeignConvention a => Stack 'UN -> Stack 'BX -> a -> IO (Stack 'UN, Stack 'BX)
mkForeign :: (ForeignConvention a, ForeignConvention r) => (a -> IO r) -> ForeignFunc
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Int
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word64
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Char
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Stack.Closure
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Text.Text
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.Function.ForeignConvention Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Time.Clock.Internal.POSIXTime.POSIXTime
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Maybe.Maybe a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (Data.Either.Either a b)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Exception.IOException
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Double
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Bool
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Base.String
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Device.SeekMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.IOMode.IOMode
instance Unison.Runtime.Foreign.Function.ForeignConvention ()
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.Foreign.Failure a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.BufferMode
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Stack.Closure]
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Foreign.Foreign]
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.MVar.MVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Conc.Sync.TVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.IORef.IORef Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.ANF.SuperGroup Unison.Symbol.Symbol)
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Foreign.Foreign
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention b
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention [b]
instance GHC.Show.Show Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Eq Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Ord Unison.Runtime.Foreign.Function.ForeignFunc

module Unison.Runtime.Decompile
decompile :: Var v => (Word64 -> Word64 -> Maybe (Term v ())) -> Closure -> Either Error (Term v ())

module Unison.Runtime.Debug
traceComb :: Bool -> Word64 -> Comb -> Bool
traceCombs :: Word64 -> Bool -> EnumMap Word64 Comb -> EnumMap Word64 Comb
tracePretty :: Var v => PrettyPrintEnv -> Bool -> Term v -> Term v
tracePrettyGroup :: Var v => Word64 -> Bool -> SuperGroup v -> SuperGroup v

module Unison.Runtime.ANF.Serialize
data TmTag
VarT :: TmTag
ForceT :: TmTag
AppT :: TmTag
HandleT :: TmTag
ShiftT :: TmTag
MatchT :: TmTag
LitT :: TmTag
NameRefT :: TmTag
NameVarT :: TmTag
LetDirT :: TmTag
LetIndT :: TmTag
data FnTag
FVarT :: FnTag
FCombT :: FnTag
FContT :: FnTag
FConT :: FnTag
FReqT :: FnTag
FPrimT :: FnTag
data MtTag
MIntT :: MtTag
MTextT :: MtTag
MReqT :: MtTag
MEmptyT :: MtTag
MDataT :: MtTag
MSumT :: MtTag
data LtTag
IT :: LtTag
NT :: LtTag
FT :: LtTag
TT :: LtTag
CT :: LtTag
LMT :: LtTag
LYT :: LtTag
data BLTag
TextT :: BLTag
ListT :: BLTag
TmLinkT :: BLTag
TyLinkT :: BLTag
BytesT :: BLTag
data VaTag
PartialT :: VaTag
DataT :: VaTag
ContT :: VaTag
BLitT :: VaTag
data CoTag
KET :: CoTag
MarkT :: CoTag
PushT :: CoTag
index :: Eq v => [v] -> v -> Maybe Word64
deindex :: HasCallStack => [v] -> Word64 -> v
putIndex :: MonadPut m => Word64 -> m ()
getIndex :: MonadGet m => m Word64
putVar :: MonadPut m => Eq v => [v] -> v -> m ()
getVar :: MonadGet m => [v] -> m v
putArgs :: MonadPut m => Eq v => [v] -> [v] -> m ()
getArgs :: MonadGet m => [v] -> m [v]
putCCs :: MonadPut m => [Mem] -> m ()
getCCs :: MonadGet m => m [Mem]
putGroup :: MonadPut m => Var v => SuperGroup v -> m ()
getGroup :: MonadGet m => Var v => m (SuperGroup v)
putComb :: MonadPut m => Var v => [v] -> SuperNormal v -> m ()
getFresh :: Var v => Word64 -> v
getComb :: MonadGet m => Var v => [v] -> Word64 -> m (SuperNormal v)
putNormal :: MonadPut m => Var v => [v] -> ANormal v -> m ()
getNormal :: MonadGet m => Var v => [v] -> Word64 -> m (ANormal v)
putFunc :: MonadPut m => Var v => [v] -> Func v -> m ()
getFunc :: MonadGet m => Var v => [v] -> m (Func v)
putPOp :: MonadPut m => POp -> m ()
getPOp :: MonadGet m => m POp
pOpAssoc :: [(POp, Word16)]
pop2word :: Map POp Word16
word2pop :: Map Word16 POp
putLit :: MonadPut m => Lit -> m ()
getLit :: MonadGet m => m Lit
putBLit :: MonadPut m => BLit -> m ()
getBLit :: MonadGet m => m BLit
putRefs :: MonadPut m => [Reference] -> m ()
getRefs :: MonadGet m => m [Reference]
putBranches :: MonadPut m => Var v => [v] -> Branched (ANormal v) -> m ()
getBranches :: MonadGet m => Var v => [v] -> Word64 -> m (Branched (ANormal v))
putCase :: MonadPut m => Var v => [v] -> ([Mem], ANormal v) -> m ()
getCase :: MonadGet m => Var v => [v] -> Word64 -> m ([Mem], ANormal v)
putCTag :: MonadPut m => CTag -> m ()
getCTag :: MonadGet m => m CTag
putGroupRef :: MonadPut m => GroupRef -> m ()
getGroupRef :: MonadGet m => m GroupRef
putValue :: MonadPut m => Value -> m ()
getValue :: MonadGet m => m Value
putCont :: MonadPut m => Cont -> m ()
getCont :: MonadGet m => m Cont
deserializeGroup :: Var v => ByteString -> Either String (SuperGroup v)
serializeGroup :: Var v => SuperGroup v -> ByteString
deserializeValue :: ByteString -> Either String Value
serializeValue :: Value -> ByteString
serializeValueLazy :: Value -> ByteString
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.CoTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.VaTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.BLTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.LtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.MtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.FnTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.TmTag

module Unison.Runtime.Builtin
builtinLookup :: Map Reference (SuperNormal Symbol)
builtinTermNumbering :: Map Reference Word64
builtinTypeNumbering :: Map Reference Word64
builtinTermBackref :: EnumMap Word64 Reference
builtinTypeBackref :: EnumMap Word64 Reference
builtinForeigns :: EnumMap Word64 ForeignFunc
numberedTermLookup :: EnumMap Word64 (SuperNormal Symbol)

module Unison.Runtime.Machine

-- | A ref storing every currently active thread. This is helpful for
--   cleaning up orphaned threads when the main process completes. We track
--   threads when running in a host process like UCM, otherwise we don't
--   bother since forked threads are cleaned up automatically on
--   termination.
type ActiveThreads = Maybe (IORef (Set ThreadId))
type Tag = Word64
type DEnv = EnumMap Word64 Closure
data CCache
CCache :: EnumMap Word64 ForeignFunc -> (Text -> Closure -> IO ()) -> TVar (EnumMap Word64 Combs) -> TVar (EnumMap Word64 Reference) -> TVar (EnumMap Word64 Reference) -> TVar Word64 -> TVar Word64 -> TVar (Map Reference (SuperGroup Symbol)) -> TVar (Map Reference Word64) -> TVar (Map Reference Word64) -> CCache
[foreignFuncs] :: CCache -> EnumMap Word64 ForeignFunc
[tracer] :: CCache -> Text -> Closure -> IO ()
[combs] :: CCache -> TVar (EnumMap Word64 Combs)
[combRefs] :: CCache -> TVar (EnumMap Word64 Reference)
[tagRefs] :: CCache -> TVar (EnumMap Word64 Reference)
[freshTm] :: CCache -> TVar Word64
[freshTy] :: CCache -> TVar Word64
[intermed] :: CCache -> TVar (Map Reference (SuperGroup Symbol))
[refTm] :: CCache -> TVar (Map Reference Word64)
[refTy] :: CCache -> TVar (Map Reference Word64)
refNumsTm :: CCache -> IO (Map Reference Word64)
refNumsTy :: CCache -> IO (Map Reference Word64)
refNumTm :: CCache -> Reference -> IO Word64
refNumTy :: CCache -> Reference -> IO Word64
refNumTy' :: CCache -> Reference -> IO (Maybe Word64)
baseCCache :: IO CCache
info :: Show a => String -> a -> IO ()
infos :: String -> String -> IO ()
eval0 :: CCache -> ActiveThreads -> Section -> IO ()
topDEnv :: Map Reference Word64 -> Map Reference Word64 -> (DEnv, K -> K)
apply0 :: Maybe (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Word64 -> IO ()
apply1 :: (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
jump0 :: (Stack 'UN -> Stack 'BX -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
lookupDenv :: Word64 -> DEnv -> Closure
exec :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Instr -> IO (DEnv, Stack 'UN, Stack 'BX, K)
eval :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Section -> IO ()
forkEval :: CCache -> ActiveThreads -> Closure -> IO ThreadId
atomicEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
enter :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Bool -> Args -> Comb -> IO ()
name :: Stack 'UN -> Stack 'BX -> Args -> Closure -> IO (Stack 'BX)
apply :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Bool -> Args -> Closure -> IO ()
jump :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> Args -> Closure -> IO ()
repush :: CCache -> ActiveThreads -> Stack 'UN -> Stack 'BX -> DEnv -> K -> K -> IO ()
moveArgs :: Stack 'UN -> Stack 'BX -> Args -> IO (Stack 'UN, Stack 'BX)
closureArgs :: Stack 'BX -> Args -> IO [Closure]
buildData :: Stack 'UN -> Stack 'BX -> Reference -> Tag -> Args -> IO Closure
dumpData :: Maybe Reference -> Stack 'UN -> Stack 'BX -> Closure -> IO (Stack 'UN, Stack 'BX)
closeArgs :: Augment -> Stack 'UN -> Stack 'BX -> Seg 'UN -> Seg 'BX -> Args -> IO (Seg 'UN, Seg 'BX)
peekForeign :: Stack 'BX -> Int -> IO a
uprim1 :: Stack 'UN -> UPrim1 -> Int -> IO (Stack 'UN)
uprim2 :: Stack 'UN -> UPrim2 -> Int -> Int -> IO (Stack 'UN)
bprim1 :: Stack 'UN -> Stack 'BX -> BPrim1 -> Int -> IO (Stack 'UN, Stack 'BX)
bprim2 :: Stack 'UN -> Stack 'BX -> BPrim2 -> Int -> Int -> IO (Stack 'UN, Stack 'BX)
yield :: CCache -> DEnv -> ActiveThreads -> Stack 'UN -> Stack 'BX -> K -> IO ()
selectTextBranch :: Text -> Section -> Map Text Section -> Section
selectBranch :: Tag -> Branch -> Section
splitCont :: DEnv -> Stack 'UN -> Stack 'BX -> K -> Word64 -> IO (K, DEnv, Stack 'UN, Stack 'BX, Seg 'UN, Seg 'BX, K)
discardCont :: DEnv -> Stack 'UN -> Stack 'BX -> K -> Word64 -> IO (DEnv, Stack 'UN, Stack 'BX, K)
resolve :: CCache -> DEnv -> Stack 'BX -> Ref -> IO Closure
combSection :: HasCallStack => CCache -> CombIx -> IO Comb
dummyRef :: Reference
reserveIds :: Word64 -> TVar Word64 -> IO Word64
updateMap :: Semigroup s => s -> TVar s -> STM s
refLookup :: String -> Map Reference Word64 -> Reference -> Word64
decodeCacheArgument :: Seq Closure -> IO [(Reference, SuperGroup Symbol)]
addRefs :: TVar Word64 -> TVar (Map Reference Word64) -> TVar (EnumMap Word64 Reference) -> Set Reference -> STM (Map Reference Word64)
codeValidate :: [(Reference, SuperGroup Symbol)] -> CCache -> IO (Maybe (Failure Closure))
cacheAdd0 :: Set Reference -> [(Reference, SuperGroup Symbol)] -> CCache -> IO ()
cacheAdd :: [(Reference, SuperGroup Symbol)] -> CCache -> IO [Reference]
reflectValue :: EnumMap Word64 Reference -> Closure -> IO Value
reifyValue :: CCache -> Value -> IO (Either [Reference] Closure)
reifyValue0 :: (Map Reference Word64, Map Reference Word64) -> Value -> IO Closure
closureNum :: Closure -> Int
universalEq :: (Foreign -> Foreign -> Bool) -> Closure -> Closure -> Bool
compareAsFloat :: Int -> Int -> Ordering
compareAsNat :: Int -> Int -> Ordering
floatTag :: Word64
natTag :: Word64
charTag :: Word64
unitTag :: Word64
universalCompare :: (Foreign -> Foreign -> Ordering) -> Closure -> Closure -> Ordering

module Unison.Runtime.Interface
startRuntime :: RuntimeHost -> String -> IO (Runtime Symbol)
standalone :: CCache -> Word64 -> IO StoredCache
runStandalone :: StoredCache -> Word64 -> IO ()
data StoredCache
decodeStandalone :: ByteString -> Either String (Text, Text, Word64, StoredCache)

-- | Whether the runtime is hosted within a UCM session or as a standalone
--   process.
data RuntimeHost
Standalone :: RuntimeHost
UCM :: RuntimeHost
instance GHC.Show.Show Unison.Runtime.Interface.StoredCache

module Unison.Util.TransitiveClosure
transitiveClosure :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> Set a -> m (Set a)
transitiveClosure' :: Ord a => (a -> Set a) -> Set a -> Set a
transitiveClosure1 :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> a -> m (Set a)
transitiveClosure1' :: Ord a => (a -> Set a) -> a -> Set a
